/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./src/BSPTree.js":
/*!************************!*\
  !*** ./src/BSPTree.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BSPNode\": () => (/* binding */ BSPNode),\n/* harmony export */   \"BSPTree\": () => (/* binding */ BSPTree),\n/* harmony export */   \"BoundBox\": () => (/* binding */ BoundBox),\n/* harmony export */   \"Edge\": () => (/* binding */ Edge),\n/* harmony export */   \"EdgeSide\": () => (/* binding */ EdgeSide),\n/* harmony export */   \"PartitionLine\": () => (/* binding */ PartitionLine),\n/* harmony export */   \"Sector\": () => (/* binding */ Sector),\n/* harmony export */   \"Segment\": () => (/* binding */ Segment),\n/* harmony export */   \"SubSector\": () => (/* binding */ SubSector)\n/* harmony export */ });\n/* harmony import */ var _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type/Int2DVertex.js */ \"./src/type/Int2DVertex.js\");\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar BSPTree = /*#__PURE__*/function () {\n  function BSPTree(woop, nodes) {\n    _classCallCheck(this, BSPTree);\n    this.woop = woop;\n    this.nodes = nodes;\n    this.root = nodes[nodes.length - 1];\n  }\n  _createClass(BSPTree, [{\n    key: \"render_nodes\",\n    value: function render_nodes(player, draw_callback) {\n      var interrupt_callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n        return false;\n      };\n      var node = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.root;\n      if (interrupt_callback()) {\n        return;\n      }\n      if (node instanceof SubSector) {\n        //leaf of the bsptree are SubSector to draw\n        draw_callback(node);\n        return;\n      }\n      if (this.is_right(player, node)) {\n        this.render_nodes(player, draw_callback, interrupt_callback, node.right);\n        if (this.check_bound_box(player, node.left_bound_box)) {\n          this.render_nodes(player, draw_callback, interrupt_callback, node.left);\n        }\n      } else {\n        this.render_nodes(player, draw_callback, interrupt_callback, node.left);\n        if (this.check_bound_box(player, node.right_bound_box)) {\n          this.render_nodes(player, draw_callback, interrupt_callback, node.right);\n        }\n      }\n    }\n  }, {\n    key: \"get_subsectors_to_render\",\n    value: function get_subsectors_to_render(player) {\n      var interrupt_callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return false;\n      };\n      var result = {\n        player_subsector: false,\n        player_sector: false,\n        subsectors: []\n      };\n      this.traverse_tree(player, this.root, result, interrupt_callback);\n      return result;\n    }\n  }, {\n    key: \"traverse_tree\",\n    value: function traverse_tree(player, node, result, interrupt_callback) {\n      if (interrupt_callback()) {\n        return;\n      }\n      if (node instanceof SubSector) {\n        if (!result.player_subsector) {\n          result.player_subsector = node.id;\n          result.player_sector = node.segments[0].edge.right.sector;\n        }\n        result.subsectors.push(node);\n        return;\n      }\n      if (this.is_right(player, node)) {\n        this.traverse_tree(player, node.right, result, interrupt_callback);\n        if (this.check_bound_box(player, node.left_bound_box)) {\n          this.traverse_tree(player, node.left, result, interrupt_callback);\n        }\n      } else {\n        this.traverse_tree(player, node.left, result, interrupt_callback);\n        if (this.check_bound_box(player, node.right_bound_box)) {\n          this.traverse_tree(player, node.right, result, interrupt_callback);\n        }\n      }\n    }\n  }, {\n    key: \"is_right\",\n    value: function is_right(player, node) {\n      var delta_x = player.position.x - node.partition_line.start.x;\n      var delta_y = player.position.y - node.partition_line.start.y;\n      return delta_x * node.partition_line.y_direction - delta_y * node.partition_line.x_direction >= 0;\n    }\n  }, {\n    key: \"check_bound_box\",\n    value: function check_bound_box(player, bound_box) {\n      var left = bound_box.top_left.x;\n      var right = bound_box.bottom_right.x;\n      var top = bound_box.top_left.y;\n      var bottom = bound_box.bottom_right.y;\n      var box_vertex_a = new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](left, bottom);\n      var box_vertex_b = new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](left, top);\n      var box_vertex_c = new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](right, top);\n      var box_vertex_d = new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](right, bottom);\n      var box_sides = [];\n      if (player.position.x < left) {\n        if (player.position.y > top) {\n          box_sides = [[box_vertex_b, box_vertex_a], [box_vertex_c, box_vertex_b]];\n        } else if (player.position.y < bottom) {\n          box_sides = [[box_vertex_b, box_vertex_a], [box_vertex_a, box_vertex_d]];\n        } else {\n          box_sides = [[box_vertex_b, box_vertex_a]];\n        }\n      } else if (player.position.x > right) {\n        if (player.position.y > top) {\n          box_sides = [[box_vertex_c, box_vertex_b], [box_vertex_d, box_vertex_c]];\n        } else if (player.position.y < bottom) {\n          box_sides = [[box_vertex_a, box_vertex_d], [box_vertex_d, box_vertex_c]];\n        } else {\n          box_sides = [[box_vertex_d, box_vertex_c]];\n        }\n      } else {\n        if (player.position.y > top) {\n          box_sides = [[box_vertex_c, box_vertex_b]];\n        } else if (player.position.y < bottom) {\n          box_sides = [[box_vertex_a, box_vertex_d]];\n        } else {\n          return true;\n        }\n      }\n      for (var i = 0; i < box_sides.length; i++) {\n        var angle_start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].point_to_angle(player.position, box_sides[i][0]), 0, 360, true, false);\n        var angle_end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].point_to_angle(player.position, box_sides[i][1]), 0, 360, true, false);\n        var angle_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(angle_start - angle_end, 0, 360, true, false);\n        var angle_span_1 = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(angle_start - player.horizontal_angle + this.woop.renderer.demi_horizontal_fov, 0, 360, true, false);\n        if (angle_span_1 < this.woop.renderer.horizontal_fov + angle_span) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }]);\n  return BSPTree;\n}();\nvar BSPNode = /*#__PURE__*/_createClass(function BSPNode(id, right_node, left_node, right_bound_box, left_bound_box, partition_line) {\n  _classCallCheck(this, BSPNode);\n  _defineProperty(this, \"ww\", void 0);\n  this.id = id;\n  this.right = right_node;\n  this.left = left_node;\n  this.right_bound_box = right_bound_box;\n  this.left_bound_box = left_bound_box;\n  this.partition_line = partition_line;\n});\nvar BoundBox = /*#__PURE__*/_createClass(function BoundBox(top_left, bottom_right) {\n  _classCallCheck(this, BoundBox);\n  this.top_left = top_left;\n  this.bottom_right = bottom_right;\n});\nvar PartitionLine = /*#__PURE__*/_createClass(function PartitionLine(start, end) {\n  var x_direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var y_direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  _classCallCheck(this, PartitionLine);\n  this.start = start;\n  this.end = end;\n  this.x_direction = x_direction !== null ? x_direction : end.x - start.x;\n  this.y_direction = y_direction !== null ? y_direction : end.y - start.y;\n});\nvar SubSector = /*#__PURE__*/_createClass(function SubSector(id, segments) {\n  _classCallCheck(this, SubSector);\n  this.id = id;\n  this.segments = segments;\n});\nvar Segment = /*#__PURE__*/_createClass(function Segment(id, vertex_start, vertex_end, angle, offset, edge) {\n  _classCallCheck(this, Segment);\n  this.id = id;\n  this.vertices = [vertex_start, vertex_end];\n  this.angle = angle;\n  this.offset = offset;\n  this.edge = edge;\n});\nvar Edge = /*#__PURE__*/_createClass(function Edge(vertex_start, vertex_end, _direction, _angle, right, left) {\n  var _this = this;\n  var attributes = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  _classCallCheck(this, Edge);\n  _defineProperty(this, \"set_direction\", function (direction) {\n    if (_this.direction !== direction && [0, 1].includes(direction)) {\n      _this.direction = direction;\n      _this.right = [_this.left, _this.left = _this.right][0];\n    }\n  });\n  _defineProperty(this, \"set_angle\", function (angle) {\n    _this.angle = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(angle, 0, 360, true, false);\n  });\n  this.vertices = [vertex_start, vertex_end];\n  this.direction = _direction;\n  this.angle = _angle;\n  this.right = right;\n  this.left = left;\n  this.attributes = attributes;\n});\nvar EdgeSide = /*#__PURE__*/_createClass(function EdgeSide(offset, sector, light, upper_textures, middle_textures, lower_textures) {\n  var attributes = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  _classCallCheck(this, EdgeSide);\n  this.offset = offset;\n  this.sector = sector;\n  this.light = light;\n  this.textures = {\n    up: upper_textures,\n    middle: middle_textures,\n    low: lower_textures\n  };\n  this.attributes = attributes;\n});\nvar Sector = /*#__PURE__*/_createClass(function Sector(id, ceiling_height, floor_height, ceiling_textures, floor_texture, ceiling_light, floor_light) {\n  _classCallCheck(this, Sector);\n  this.id = id;\n  this.celling = {\n    height: ceiling_height,\n    texture: ceiling_textures,\n    light: ceiling_light\n  };\n  this.floor = {\n    height: floor_height,\n    texture: floor_texture,\n    light: floor_light\n  };\n});\n\n//# sourceURL=webpack://woop/./src/BSPTree.js?");

/***/ }),

/***/ "./src/Debugger.js":
/*!*************************!*\
  !*** ./src/Debugger.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Debugger)\n/* harmony export */ });\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar Debugger = /*#__PURE__*/function () {\n  function Debugger(woop) {\n    var enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, Debugger);\n    this.woop = woop;\n    this.enable = enable;\n    this.is_init = false;\n    this.head = null;\n    this.body = null;\n    this.map_context = null;\n    this.data = {};\n  }\n  _createClass(Debugger, [{\n    key: \"clear_data\",\n    value: function clear_data() {\n      this.data = {};\n    }\n  }, {\n    key: \"update_data\",\n    value: function update_data(index, value) {\n      this.data[index] = value;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      var head = document.createElement(\"pre\");\n      var body = document.createElement(\"pre\");\n      var ratio = Math.min(200 / this.woop.level.size.x, 200 / this.woop.level.size.y);\n      var map_display_x = Math.round(this.woop.level.size.x * ratio);\n      var map_display_y = Math.round(this.woop.level.size.y * ratio);\n      head.id = \"debug_head\";\n      head.style.position = \"absolute\";\n      head.style.display = \"block\";\n      head.style.top = \"50px\";\n      head.style.right = \"50px\";\n      head.style.width = \"216px\";\n      head.style.height = \"16px\";\n      head.style.backgroundColor = \"#850000\";\n      head.style.color = \"#ffffff\";\n      head.style.margin = \"0px\";\n      head.style.padding = \"2px\";\n      head.innerHTML += \"Debugger <span style='float:right' id='debug_frame_rate'></span><br>\";\n      body.id = \"debug_body\";\n      body.style.position = \"absolute\";\n      body.style.display = \"none\";\n      body.style.top = \"70px\";\n      body.style.right = \"50px\";\n      body.style.width = \"200px\";\n      body.style.backgroundColor = \"#ffffffaa\";\n      body.style.margin = \"0px\";\n      body.style.padding = \"10px\";\n      body.innerHTML += \"Fps : <span id='debug_frame_rate2'></span><br>\";\n      body.innerHTML += \"Game state : <span id='debug_game_state'></span><br>\";\n      body.innerHTML += \"viewport resolution : <span id='debug_vp_res'></span><br>\";\n      body.innerHTML += \"Internal resolution : <span id='debug_int_res'></span><br>\";\n      body.innerHTML += \"Pixel scale : <span id='debug_p_scale'></span><br>\";\n      body.innerHTML += \"Keys press : <span id='debug_keys'></span><br>\";\n      body.innerHTML += \"Mouse position : <span id='debug_mouse'></span><br>\";\n      body.innerHTML += \"Cursor position : <span id='debug_cursor'></span><br>\";\n      body.innerHTML += \"Editor position : <span id='debug_editor_pos'></span><br>\";\n      //body.innerHTML             += \"<canvas id='debug_map' width='\"+map_display_x+\"' height='\"+map_display_y+\"'></canvas>\"\n      body.innerHTML += \"Player position : <br><span id='debug_p_pos'></span><br><span id='debug_p_ang'></span><br>\";\n      body.innerHTML += \"Data : <br><span id='debug_data'></span><br>\";\n      document.body.append(head);\n      document.body.append(body);\n      this.head = head;\n      this.body = body;\n      //this.map_context             = document.getElementById( \"debug_map\" ).getContext( \"2d\" )\n      //this.map_context.fillStyle   = \"rgba( 0, 0, 0 , 1 )\"\n      //this.map_context.strokeStyle = \"rgba( 0, 0, 0 , 1 )\"\n      //this.map_context.strokeRect( 0, 0, map_display_x, map_display_y )\n\n      this.head.addEventListener('click', function () {\n        _this.body.display = _this.body.display === \"block\" ? \"none\" : \"block\";\n        _this.body.style.setProperty('display', _this.body.display);\n      });\n      this.is_init = true;\n    }\n  }, {\n    key: \"switch\",\n    value: function _switch() {\n      this.enable = !this.enable;\n      if (!this.enable) {\n        this.body.remove();\n        this.body = null;\n        this.is_init = false;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.enable) {\n        return;\n      }\n      if (!this.is_init) {\n        this.init();\n      }\n      document.getElementById(\"debug_game_state\").innerHTML = this.woop.game_state;\n      document.getElementById(\"debug_vp_res\").innerHTML = \"<br>y-\" + this.woop.renderer.canvas.width + \" x-\" + this.woop.renderer.canvas.height;\n      document.getElementById(\"debug_int_res\").innerHTML = \"<br>y-\" + this.woop.renderer.internal_width + \" x-\" + this.woop.renderer.internal_height;\n      document.getElementById(\"debug_frame_rate\").innerHTML = this.woop.time.last_frame_count;\n      document.getElementById(\"debug_frame_rate2\").innerHTML = this.woop.time.last_frame_count;\n      document.getElementById(\"debug_keys\").innerHTML = '<br>' + JSON.stringify(Array.from(this.woop.inputs.input_status).join(\" ,<br>\"));\n      document.getElementById(\"debug_mouse\").innerHTML = \"<br>mouse \" + (this.woop.inputs.mouse_lock ? \"lock \" : \"unlock \") + \"x-\" + this.woop.inputs.mouse_movements.x + \" y-\" + this.woop.inputs.mouse_movements.y;\n      document.getElementById(\"debug_cursor\").innerHTML = \"<br>x-\" + this.woop.editor.cursor.position.x + \" <br>y-\" + this.woop.editor.cursor.position.y;\n      document.getElementById(\"debug_editor_pos\").innerHTML = \"<br>x-\" + this.woop.editor.grid_pos.x + \" <br>y-\" + this.woop.editor.grid_pos.y;\n      document.getElementById(\"debug_p_pos\").innerHTML = \"<br>x-\" + this.woop.player.position.x + \" <br>y-\" + this.woop.player.position.y + \" <br>z-\" + this.woop.player.position.z;\n      document.getElementById(\"debug_p_ang\").innerHTML = \"h_angle-\" + this.woop.player.horizontal_angle + \" v_angle-\" + this.woop.player.look_vertical;\n      document.getElementById(\"debug_data\").innerHTML = JSON.stringify(this.data, null, 2);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.enable) {\n        return;\n      }\n      if (!this.is_init) {\n        this.init();\n      }\n      var ratio = Math.min(200 / this.woop.level.size.x, 200 / this.woop.level.size.y);\n      var map_display_x = Math.round(this.woop.level.size.x * ratio);\n      var map_display_y = Math.round(this.woop.level.size.y * ratio);\n      var x1 = Math.round(this.woop.player.position.x / this.woop.level.size.x * map_display_x);\n      var y1 = Math.round((this.woop.level.size.y - this.woop.player.position.y) / this.woop.level.size.y * map_display_y);\n      var map_look = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].angle_range(this.woop.player.horizontal_angle - 90);\n      var x2 = Math.round(x1 + 10 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookup_cos[map_look]);\n      var y2 = Math.round(y1 + 10 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookup_sin[map_look]);\n      // clear map\n      //this.map_context.fillStyle = \"rgba( 0, 0, 0 , 0)\"\n      //this.map_context.strokeStyle = \"rgba( 0, 0, 0 , 1)\"\n      //this.map_context.clearRect(1, 1, map_display_x - 2, map_display_y - 2 )\n      //this.map_context.strokeRect(0, 0, map_display_x, map_display_y )\n      // player pos\n      //this.map_context.beginPath()\n      //this.map_context.fillStyle = \"rgba( 245, 40, 145 , 1)\"\n      //this.map_context.arc( x1, y1, 2, 0, 2 * Math.PI, false )\n      //this.map_context.fill()\n      // arrow\n      //this.map_context.fillStyle = \"rgba( 0, 0, 0 , 0 )\"\n      //this.map_context.strokeStyle = \"rgba( 40, 40, 40 , 1 )\"\n      //this.map_context.beginPath()\n      //this.map_context.moveTo( x1, y1 )\n      //this.map_context.lineTo( x2, y2 )\n      //this.map_context.stroke()\n    }\n  }]);\n  return Debugger;\n}();\n\n\n//# sourceURL=webpack://woop/./src/Debugger.js?");

/***/ }),

/***/ "./src/Editor.js":
/*!***********************!*\
  !*** ./src/Editor.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Editor)\n/* harmony export */ });\n/* harmony import */ var _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type/Int2DVertex.js */ \"./src/type/Int2DVertex.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"./src/const.js\");\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar Editor = /*#__PURE__*/function () {\n  function Editor(woop) {\n    _classCallCheck(this, Editor);\n    this.woop = woop;\n    this.grid_pos = woop.level.boundary[0].clone();\n    this.grid_zoom = 13;\n    this.unit_pixel_size = .016;\n    this.unit_by_ceil = 100;\n    this.cursor = {\n      state: _const_js__WEBPACK_IMPORTED_MODULE_1__.CURSORS.ARROW,\n      position: new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.woop.renderer.canvas.width / 2, this.woop.renderer.canvas.height / 2)\n    };\n    this.grid_pos.set_x(this.grid_pos.x - 200);\n    this.grid_pos.set_y(this.grid_pos.y + 200);\n  }\n  _createClass(Editor, [{\n    key: \"grid_scale\",\n    value: function grid_scale() {\n      return this.unit_pixel_size * this.grid_zoom;\n    }\n  }, {\n    key: \"ceil_pixel_size\",\n    value: function ceil_pixel_size() {\n      return this.unit_pixel_size * this.unit_by_ceil * this.grid_zoom;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.cursor.position.set_x(_WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].value_range(this.cursor.position.x + this.woop.inputs.mouse_movements.x, 0, this.woop.renderer.canvas.width));\n      this.cursor.position.set_y(_WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].value_range(this.cursor.position.y + this.woop.inputs.mouse_movements.y, 0, this.woop.renderer.canvas.height));\n      this.grid_zoom = _WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].value_range(this.grid_zoom - this.woop.inputs.mouse_movements.wheel / 100, 5, 40);\n      if (this.woop.inputs.input_status.has(\"editor_grab_down\")) {\n        this.cursor.state = _const_js__WEBPACK_IMPORTED_MODULE_1__.CURSORS.GRAB;\n        this.grid_pos.set_x(this.grid_pos.x - this.woop.inputs.mouse_movements.x / this.unit_pixel_size / this.grid_zoom);\n        this.grid_pos.set_y(this.grid_pos.y + this.woop.inputs.mouse_movements.y / this.unit_pixel_size / this.grid_zoom);\n      } else {\n        this.cursor.state = _const_js__WEBPACK_IMPORTED_MODULE_1__.CURSORS.ARROW;\n      }\n      if (this.woop.debbuger.enable) {\n        if (this.woop.inputs.input_status.has(\"look_left_down\")) {\n          this.woop.player.horizontal_angle += 2;\n        }\n        if (this.woop.inputs.input_status.has(\"look_right_down\")) {\n          this.woop.player.horizontal_angle -= 2;\n        }\n        this.woop.player.horizontal_angle = _WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].angle_range(this.woop.player.horizontal_angle);\n        var delta_y = Math.round(_WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lookup_sin(this.woop.player.horizontal_angle) * 6.0);\n        var delta_x = Math.round(_WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lookup_cos(this.woop.player.horizontal_angle) * 6.0);\n        if (this.woop.inputs.input_status.has(\"forward_down\") && !this.woop.inputs.input_status.has(\"look_up_down\")) {\n          this.woop.player.position.x += delta_x;\n          this.woop.player.position.y += delta_y;\n        }\n        if (this.woop.inputs.input_status.has(\"backward_down\") && !this.woop.inputs.input_status.has(\"look_down_down\")) {\n          this.woop.player.position.x -= delta_x;\n          this.woop.player.position.y -= delta_y;\n        }\n        if (this.woop.inputs.input_status.has(\"strafe_right_down\") && !this.woop.inputs.input_status.has(\"look_right_down\")) {\n          this.woop.player.position.x += delta_y;\n          this.woop.player.position.y -= delta_x;\n        }\n        if (this.woop.inputs.input_status.has(\"strafe_left_down\") && !this.woop.inputs.input_status.has(\"look_left_down\")) {\n          this.woop.player.position.x -= delta_y;\n          this.woop.player.position.y += delta_x;\n        }\n\n        //TODO:: add boundaries\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer) {\n      renderer.draw_background(\"black\");\n      renderer.update_render_variables(\"editor\", {\n        grid_scale: this.grid_scale(),\n        pixel_x_offset: this.grid_pos.x * this.unit_pixel_size * this.grid_zoom,\n        pixel_y_offset: this.grid_pos.y * -1 * this.unit_pixel_size * this.grid_zoom\n      });\n\n      //draw grid\n      renderer.draw_editor_grid();\n\n      //draw level\n      if (this.woop.level) {\n        //draw level boundary\n        renderer.draw_editor_box(this.woop.level.boundary[0].x, this.woop.level.boundary[0].y, this.woop.level.boundary[1].x, this.woop.level.boundary[1].y);\n        //draw vertices\n        this.woop.level.vertices.forEach(function (vertex) {\n          renderer.draw_editor_point(vertex.x, vertex.y);\n        });\n        //draw edge and edge direction\n        this.woop.level.segments.forEach(function (segment) {\n          renderer.draw_editor_line(segment.vertices[0].x, segment.vertices[0].y, segment.vertices[1].x, segment.vertices[1].y);\n          var from = [Math.round((segment.vertices[0].x + segment.vertices[1].x) / 2), Math.round((segment.vertices[0].y + segment.vertices[1].y) / 2)];\n          var to = [Math.round(from[0] + 8 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lookup_cos(segment.angle + 90)), Math.round(from[1] + 8 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lookup_sin(segment.angle + 90))];\n          renderer.draw_editor_line(from[0], from[1], to[0], to[1]);\n        });\n        //draw edge visible from the bsp tree\n        renderer.draw_editor_sector_in_field_of_view();\n      }\n      if (this.woop.player) {\n        renderer.draw_editor_player();\n      }\n      if (this.woop.inputs.mouse_lock) {\n        renderer.draw_cursor(this.cursor.position.x, this.cursor.position.y, this.cursor.state);\n      }\n    }\n  }]);\n  return Editor;\n}();\n\n\n//# sourceURL=webpack://woop/./src/Editor.js?");

/***/ }),

/***/ "./src/Game.js":
/*!*********************!*\
  !*** ./src/Game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar Game = /*#__PURE__*/_createClass(function Game(woop) {\n  var _this = this;\n  _classCallCheck(this, Game);\n  _defineProperty(this, \"update\", function () {\n    //crud z update\n    _this.woop.player.position.set_z(_this.woop.player.floor_hight + _this.woop.player.height);\n    if (_this.woop.inputs.mouse_lock) {\n      _this.woop.player.horizontal_angle -= Math.round(_this.woop.inputs.mouse_movements.x / 8);\n    } else {\n      if (_this.woop.inputs.input_status.has(\"look_left_down\")) {\n        _this.woop.player.horizontal_angle += 2;\n      }\n      if (_this.woop.inputs.input_status.has(\"look_right_down\")) {\n        _this.woop.player.horizontal_angle -= 2;\n      }\n    }\n    _this.woop.player.horizontal_angle = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].angle_range(_this.woop.player.horizontal_angle);\n    var delta_y = Math.round(_WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookup_sin(_this.woop.player.horizontal_angle) * 6.0);\n    var delta_x = Math.round(_WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookup_cos(_this.woop.player.horizontal_angle) * 6.0);\n    if (_this.woop.inputs.mouse_lock) {\n      _this.woop.player.look_vertical -= Math.round(_this.woop.inputs.mouse_movements.y / 16);\n    } else {\n      if (_this.woop.inputs.input_status.has(\"look_up_down\")) {\n        _this.woop.player.look_vertical -= 1;\n      }\n      if (_this.woop.inputs.input_status.has(\"look_down_down\")) {\n        _this.woop.player.look_vertical += 1;\n      }\n    }\n    _this.woop.player.look_vertical = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].angle_range(_this.woop.player.look_vertical, -90, 90, false);\n    if (_this.woop.inputs.input_status.has(\"forward_down\") && !_this.woop.inputs.input_status.has(\"look_up_down\")) {\n      _this.woop.player.position.x += delta_x;\n      _this.woop.player.position.y += delta_y;\n    }\n    if (_this.woop.inputs.input_status.has(\"backward_down\") && !_this.woop.inputs.input_status.has(\"look_down_down\")) {\n      _this.woop.player.position.x -= delta_x;\n      _this.woop.player.position.y -= delta_y;\n    }\n    if (_this.woop.inputs.input_status.has(\"strafe_right_down\") && !_this.woop.inputs.input_status.has(\"look_right_down\")) {\n      _this.woop.player.position.x += delta_y;\n      _this.woop.player.position.y -= delta_x;\n    }\n    if (_this.woop.inputs.input_status.has(\"strafe_left_down\") && !_this.woop.inputs.input_status.has(\"look_left_down\")) {\n      _this.woop.player.position.x -= delta_y;\n      _this.woop.player.position.y += delta_x;\n    }\n    if (_this.woop.inputs.input_status.has(\"up_down\")) {\n      _this.woop.player.position.z += 4;\n    }\n    if (_this.woop.inputs.input_status.has(\"down_down\")) {\n      _this.woop.player.position.z -= 4;\n    }\n\n    //TODO:: add boundaries\n  });\n  _defineProperty(this, \"render\", function (renderer) {\n    renderer.draw_background();\n\n    //draw from bsp tree\n    if (_this.woop.level) {\n      _this.woop.debbuger.clear_data();\n      renderer.draw_game_sector_in_field_of_view();\n    }\n  });\n  this.woop = woop;\n});\n\n\n//# sourceURL=webpack://woop/./src/Game.js?");

/***/ }),

/***/ "./src/InputManager.js":
/*!*****************************!*\
  !*** ./src/InputManager.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InputManager)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar InputManager = /*#__PURE__*/function () {\n  function InputManager(woop) {\n    _classCallCheck(this, InputManager);\n    this.woop = woop;\n    this.mouse_lock = false;\n    this.input_status = new Set();\n    this.keys_press = {\n      keys_up: new Set(),\n      keys_down: new Set()\n    };\n    this.mouse_press = {\n      buttons_up: new Set(),\n      buttons_down: new Set()\n    };\n    this.mouse_movements = {\n      x: 0,\n      y: 0,\n      wheel: 0\n    };\n    this.keys_map = {\n      editor_mode: [9],\n      game_mode: [9],\n      escape: [27],\n      enter: [13],\n      forward: [87],\n      backward: [83],\n      strafe_left: [65],\n      strafe_right: [68],\n      look_left: [16, 65],\n      look_right: [16, 68],\n      look_up: [16, 87],\n      look_down: [16, 83],\n      up: [81],\n      down: [69]\n    };\n    this.mouse_buttons_map = {\n      editor_grab: [0],\n      mouse_middle: [1],\n      mouse_right: [2],\n      mouse_page_down: [3],\n      mouse_page_up: [4]\n    };\n    this.init_input_listener();\n  }\n  _createClass(InputManager, [{\n    key: \"resolve_keys\",\n    value: function resolve_keys() {\n      var _this = this;\n      //resolve mapped keys press\n      Object.keys(this.keys_map).forEach(function (key) {\n        var key_down = true;\n        var key_up = true;\n        _this.keys_map[key].forEach(function (k) {\n          if (!_this.keys_press.keys_down.has(k)) {\n            key_down = false;\n          }\n        });\n        _this.keys_map[key].forEach(function (k) {\n          if (!_this.keys_press.keys_up.has(k)) {\n            key_up = false;\n          }\n        });\n        if (key_down) {\n          _this.input_status.add(key + \"_down\");\n        } else {\n          _this.input_status[\"delete\"](key + \"_down\");\n        }\n        if (key_up) {\n          _this.input_status.add(key + \"_release\");\n        } else {\n          _this.input_status[\"delete\"](key + \"_release\");\n        }\n      });\n      Object.keys(this.mouse_buttons_map).forEach(function (button) {\n        var key_down = true;\n        var key_up = true;\n        _this.mouse_buttons_map[button].forEach(function (k) {\n          if (!_this.mouse_press.buttons_down.has(k)) {\n            key_down = false;\n          }\n        });\n        _this.mouse_buttons_map[button].forEach(function (k) {\n          if (!_this.mouse_press.buttons_up.has(k)) {\n            key_up = false;\n          }\n        });\n        if (key_down) {\n          _this.input_status.add(button + \"_down\");\n        } else {\n          _this.input_status[\"delete\"](button + \"_down\");\n        }\n        if (key_up) {\n          _this.input_status.add(button + \"_release\");\n        } else {\n          _this.input_status[\"delete\"](button + \"_release\");\n        }\n      });\n      this.keys_press.keys_up.clear();\n      this.mouse_press.buttons_up.clear();\n    }\n  }, {\n    key: \"clear_mouse_movements\",\n    value: function clear_mouse_movements() {\n      this.mouse_movements.x = 0;\n      this.mouse_movements.y = 0;\n      this.mouse_movements.wheel = 0;\n    }\n  }, {\n    key: \"update_mouse_movements\",\n    value: function update_mouse_movements(input_manager, event) {\n      input_manager.mouse_movements.x += event.movementX * .5;\n      input_manager.mouse_movements.y += event.movementY * .5;\n    }\n  }, {\n    key: \"update_mouse_wheel\",\n    value: function update_mouse_wheel(input_manager, event) {\n      input_manager.mouse_movements.wheel += event.deltaY;\n    }\n  }, {\n    key: \"update_key_up\",\n    value: function update_key_up(input_manager, event) {\n      event.preventDefault();\n      input_manager.keys_press.keys_up.add(event.keyCode);\n      input_manager.keys_press.keys_down[\"delete\"](event.keyCode);\n    }\n  }, {\n    key: \"update_key_down\",\n    value: function update_key_down(input_manager, event) {\n      event.preventDefault();\n      input_manager.keys_press.keys_down.add(event.keyCode);\n      input_manager.keys_press.keys_up[\"delete\"](event.keyCode);\n    }\n  }, {\n    key: \"update_mouse_click_up\",\n    value: function update_mouse_click_up(input_manager, event) {\n      input_manager.mouse_press.buttons_up.add(event.button);\n      input_manager.mouse_press.buttons_down[\"delete\"](event.button);\n    }\n  }, {\n    key: \"update_mouse_click_down\",\n    value: function update_mouse_click_down(input_manager, event) {\n      input_manager.mouse_press.buttons_up[\"delete\"](event.button);\n      input_manager.mouse_press.buttons_down.add(event.button);\n    }\n  }, {\n    key: \"init_input_listener\",\n    value: function init_input_listener() {\n      var _this2 = this;\n      window.addEventListener(\"keyup\", function (event) {\n        _this2.update_key_up(_this2, event);\n      }, true);\n      window.addEventListener(\"keydown\", function (event) {\n        _this2.update_key_down(_this2, event);\n      }, true);\n      document.addEventListener(\"pointerlockchange\", function () {\n        if (document.pointerLockElement) {\n          _this2.mouse_lock = true;\n          document.addEventListener(\"mousemove\", function (event) {\n            _this2.update_mouse_movements(_this2, event);\n          }, true);\n          document.addEventListener(\"wheel\", function (event) {\n            _this2.update_mouse_wheel(_this2, event);\n          }, true);\n          document.addEventListener(\"mouseup\", function (event) {\n            _this2.update_mouse_click_up(_this2, event);\n          }, true);\n          document.addEventListener(\"mousedown\", function (event) {\n            _this2.update_mouse_click_down(_this2, event);\n          }, true);\n        } else {\n          _this2.mouse_lock = false;\n          document.removeEventListener(\"mousemove\", _this2.update_mouse_movements);\n          document.removeEventListener(\"wheel\", _this2.update_mouse_wheel);\n          document.removeEventListener(\"mouseup\", _this2.update_mouse_click_up);\n          document.removeEventListener(\"mousedown\", _this2.update_mouse_click_down);\n        }\n      });\n      this.woop.renderer.canvas.addEventListener(\"click\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (document.pointerLockElement) {\n                _context.next = 3;\n                break;\n              }\n              _context.next = 3;\n              return _this2.woop.renderer.canvas.requestPointerLock({\n                unadjustedMovement: true\n              });\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      })), false);\n    }\n  }]);\n  return InputManager;\n}();\n\n\n//# sourceURL=webpack://woop/./src/InputManager.js?");

/***/ }),

/***/ "./src/Level.js":
/*!**********************!*\
  !*** ./src/Level.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Level)\n/* harmony export */ });\n/* harmony import */ var _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type/Int2DVertex.js */ \"./src/type/Int2DVertex.js\");\n/* harmony import */ var _type_Int3DVertex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type/Int3DVertex.js */ \"./src/type/Int3DVertex.js\");\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Player.js */ \"./src/Player.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar Level = /*#__PURE__*/function () {\n  function Level(woop) {\n    _classCallCheck(this, Level);\n    this.woop = woop;\n    this.name = 'void';\n    this.vertices = [];\n    this.segments = [];\n    this.size = new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1, 1);\n    this.bsp_tree = null;\n    this.boundary = [new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0), new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1, 1)];\n    this.player_start = {\n      position: new _type_Int3DVertex_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1, 1, 45),\n      horizontal_angle: 0,\n      vertical_angle: 0\n    };\n  }\n  _createClass(Level, [{\n    key: \"load_from_wad\",\n    value: function load_from_wad(wad_loader, map_name) {\n      var map_data = wad_loader.get_map_data(map_name);\n      this.name = map_name;\n      this.size = map_data.get_size();\n      this.boundary = map_data.get_boundary();\n      this.bsp_tree = map_data.get_bsp_tree();\n      this.player_start = map_data.get_player_start();\n      this.vertices = map_data.get_vertices();\n      this.segments = map_data.get_segments();\n    }\n  }, {\n    key: \"spawn_player\",\n    value: function spawn_player(player_height) {\n      var player = new _Player_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.player_start.position, this.player_start.horizontal_angle, this.player_start.vertical_angle, player_height);\n      var result = this.bsp_tree.get_subsectors_to_render(player);\n      player.position.set_z(player_height + result.player_sector.floor.height);\n      return player;\n    }\n  }]);\n  return Level;\n}();\n\n\n//# sourceURL=webpack://woop/./src/Level.js?");

/***/ }),

/***/ "./src/Player.js":
/*!***********************!*\
  !*** ./src/Player.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Player)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nvar Player = /*#__PURE__*/_createClass(function Player(position) {\n  var horizontal_angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var vertical_angle = arguments.length > 2 ? arguments[2] : undefined;\n  var height = arguments.length > 3 ? arguments[3] : undefined;\n  _classCallCheck(this, Player);\n  this.position = position;\n  this.horizontal_angle = horizontal_angle;\n  this.vertical_angle = vertical_angle;\n  this.height = height;\n  this.floor_hight = 0;\n});\n\n\n//# sourceURL=webpack://woop/./src/Player.js?");

/***/ }),

/***/ "./src/Renderer.js":
/*!*************************!*\
  !*** ./src/Renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"./src/const.js\");\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\n/* harmony import */ var _ScreenSpace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScreenSpace.js */ \"./src/ScreenSpace.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(woop, canvas, render_mode, field_of_view, pixel_scale) {\n    var _this = this;\n    _classCallCheck(this, Renderer);\n    //resize\n    _defineProperty(this, \"resize\", function () {\n      _this.canvas.width = window.visualViewport.width;\n      _this.canvas.height = window.visualViewport.height;\n      _this.internal_width = Math.round(_this.canvas.width / _this.pixel_scale);\n      _this.internal_height = Math.round(_this.canvas.height / _this.pixel_scale);\n      _this.demi_internal_width = _this.internal_width / 2;\n      _this.demi_internal_height = _this.internal_height / 2;\n      _this.horizontal_fov = _this.fov;\n      _this.demi_horizontal_fov = _this.horizontal_fov / 2;\n      /* maybe you can find a way to adjust fov from desired fov and screen aspect ratio\r\n          FOV_Horizontal = 2 * atan(W/2/f) = 2 * atan2(W/2, f)  radians\r\n          FOV_Vertical   = 2 * atan(H/2/f) = 2 * atan2(H/2, f)  radians\r\n          FOV_Diagonal   = 2 * atan2(sqrt(W^2 + H^2)/2, f)    radians\r\n          this.aspect_ratio = this.internal_width / this.internal_height\r\n          this.vertical_fov = WoopMath.degrees_to_radians( 2 * Math.atan2( this.demi_internal_height, this.fov ) )\r\n          this.vertical_fov = this.vertical_fov / 2\r\n      */\n      _this.screen_distance = _this.demi_internal_width / Math.tan(_WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degrees_to_radians(_this.demi_horizontal_fov));\n      _this.screen_space = new _ScreenSpace_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_this.internal_width, _this.internal_height);\n      _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init(_this);\n    });\n    //useful dataset from editor or game\n    _defineProperty(this, \"update_render_variables\", function () {\n      var set_name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'common';\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof _this.data_sets[set_name] === \"undefined\") {\n        _this.data_sets[set_name] = {};\n      }\n      Object.entries(data).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          value = _ref2[1];\n        _this.data_sets[set_name][key] = value;\n      });\n    });\n    _defineProperty(this, \"get_from_data_sets\", function () {\n      var set_name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'common';\n      var var_name = arguments.length > 1 ? arguments[1] : undefined;\n      if (typeof _this.data_sets[set_name] === \"undefined\" || typeof _this.data_sets[set_name][var_name] === \"undefined\") {\n        return null;\n      }\n      return _this.data_sets[set_name][var_name];\n    });\n    //draw interface\n    _defineProperty(this, \"draw\", function (what) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      if (typeof _this['draw_' + what + '_' + _this.render_mode] !== \"function\") {\n        console.log('no ' + _this.render_mode + ' draw_' + what + ' function.');\n        return;\n      }\n      _this['draw_' + what + '_' + _this.render_mode].apply(_this, _toConsumableArray(args));\n    });\n    //common draw function\n    _defineProperty(this, \"draw_background\", function () {\n      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"background\";\n      _this.draw('background', [color]);\n    });\n    _defineProperty(this, \"draw_text\", function (x, y, text) {\n      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"white\";\n      var size = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 6;\n      _this.draw('text', [x, y, text, color, size]);\n    });\n    _defineProperty(this, \"draw_cursor\", function (x, y) {\n      var cursor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const_js__WEBPACK_IMPORTED_MODULE_0__.CURSORS.ARROW;\n      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"white\";\n      var alpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n      _this.draw('cursor', [x, y, cursor, color, alpha]);\n    });\n    _defineProperty(this, \"draw_editor_grid\", function () {\n      _this.draw('editor_grid', []);\n    });\n    _defineProperty(this, \"draw_editor_player\", function () {\n      var player = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.woop.player;\n      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"red\";\n      _this.draw('editor_player', [player, color]);\n    });\n    _defineProperty(this, \"draw_editor_bound_box\", function (bound_box) {\n      _this.draw('editor_bound_box', [bound_box]);\n    });\n    _defineProperty(this, \"draw_editor_sub_sector\", function (sub_sector) {\n      _this.draw('editor_sub_sector', [sub_sector]);\n    });\n    _defineProperty(this, \"draw_bsp_nodes\", function () {\n      var bsp_node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.woop.level.bsp_tree.root;\n      _this.draw('editor_bsp_nodes', [bsp_node]);\n    });\n    _defineProperty(this, \"draw_editor_sector_in_field_of_view\", function () {\n      var bsp_tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.woop.level.bsp_tree;\n      _this.draw('editor_sector_in_field_of_view', [bsp_tree]);\n    });\n    //game draw function\n    _defineProperty(this, \"draw_game_pixel\", function (x, y) {\n      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"white\";\n      var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      _this.draw('game_pixel', [x, y, color, alpha]);\n    });\n    _defineProperty(this, \"draw_game_line\", function (start_x, start_y, end_x, end_y, texture, light) {\n      _this.draw('game_line', [start_x, start_y, end_x, end_y, texture, light]);\n    });\n    _defineProperty(this, \"draw_game_vertical_line\", function (x, start_y, end_y) {\n      var texture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'default';\n      var light = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 50;\n      _this.draw('game_vertical_line', [x, start_y, end_y, texture, light]);\n    });\n    _defineProperty(this, \"draw_game_edge\", function (segment, angle_start, x_star, x_end, range_x_star, range_x_end) {\n      _this.draw('game_edge', [segment, angle_start, x_star, x_end, range_x_star, range_x_end]);\n    });\n    _defineProperty(this, \"draw_game_sector_in_field_of_view\", function () {\n      var bsp_tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.woop.level.bsp_tree;\n      _this.draw('game_sector_in_field_of_view', [bsp_tree]);\n    });\n    _defineProperty(this, \"draw_game_sub_sector\", function (sub_sector) {\n      _this.draw('game_sub_sector', [sub_sector]);\n    });\n    this.woop = woop;\n    this.canvas = canvas;\n    this.render_mode = render_mode;\n    this.fov = field_of_view;\n    this.pixel_scale = pixel_scale;\n    this.data_sets = {};\n    this.screen_space = null;\n    this.colors = {\n      \"black\": [33, 33, 33],\n      \"blacker black\": [0, 0, 0],\n      \"white\": [255, 255, 255],\n      \"lite grey\": [210, 210, 210],\n      \"grey\": [150, 150, 150],\n      \"dark grey\": [100, 100, 100],\n      \"yellow\": [255, 255, 0],\n      \"dark yellow\": [160, 160, 0],\n      \"green\": [0, 255, 0],\n      \"dark green\": [0, 160, 0],\n      \"cyan\": [0, 255, 255],\n      \"dark cyan\": [0, 160, 160],\n      \"red\": [200, 0, 0],\n      \"dark red\": [150, 0, 0],\n      \"blue\": [0, 0, 200],\n      \"dark blue\": [0, 0, 130],\n      \"brown\": [160, 100, 0],\n      \"dark brown\": [110, 50, 0],\n      \"background\": [0, 60, 130]\n    };\n    switch (this.render_mode) {\n      case \"2D\":\n      default:\n        this.context = canvas.getContext(\"2d\");\n        break;\n    }\n    this.init_listener();\n    this.resize();\n  }\n\n  //screen related events\n  _createClass(Renderer, [{\n    key: \"init_listener\",\n    value: function init_listener() {\n      var _this2 = this;\n      window.addEventListener('resize', function () {\n        _this2.resize();\n      });\n    }\n  }, {\n    key: \"add_color\",\n    value:\n    //color stuff\n    function add_color(color_name, r, g, b) {\n      if (typeof this.colors[color_name] === \"undefined\") {\n        this.colors[color_name] = [_WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].value_range(r, 0, 255), _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].value_range(g, 0, 255), _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].value_range(b, 0, 255)];\n      }\n    }\n  }, {\n    key: \"get_color\",\n    value: function get_color(color) {\n      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var has_css = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var a = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].value_range(alpha, 0, 1);\n      if (typeof this.colors[color] === \"undefined\") {\n        this.add_color(color, _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].random_int_range(100, 255), _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].random_int_range(100, 255), _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].random_int_range(100, 255));\n      }\n      var c = this.colors[color];\n      if (a === 1) {\n        return has_css ? \"rgb(\" + c[0] + \",\" + c[1] + \",\" + c[2] + \" )\" : c;\n      }\n      return has_css ? \"rgba(\" + c[0] + \",\" + c[1] + \",\" + c[2] + \",\" + a + \" )\" : c;\n    }\n  }, {\n    key: \"draw_editor_point\",\n    value:\n    //editor draw function\n    function draw_editor_point(x, y) {\n      var stroke_color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"grey\";\n      var stroke_alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var fill_color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"dark grey\";\n      var fill_alpha = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n      var radius = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 4;\n      var stroke_size = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2;\n      this.draw('editor_point', [x, y, stroke_color, stroke_alpha, fill_color, fill_alpha, radius, stroke_size]);\n    }\n  }, {\n    key: \"draw_editor_line\",\n    value: function draw_editor_line(start_x, start_y, end_x, end_y) {\n      var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"dark grey\";\n      var alpha = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n      var size = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2;\n      this.draw('editor_line', [start_x, start_y, end_x, end_y, color, alpha, size]);\n    }\n  }, {\n    key: \"draw_editor_box\",\n    value: function draw_editor_box(top_left_x, top_left_y, bottom_right_x, bottom_right_y) {\n      var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"green\";\n      var alpha = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n      var size = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2;\n      this.draw('editor_box', [top_left_x, top_left_y, bottom_right_x, bottom_right_y, color, alpha, size]);\n    }\n  }]);\n  return Renderer;\n}();\n\n\n//# sourceURL=webpack://woop/./src/Renderer.js?");

/***/ }),

/***/ "./src/Renderer2D.js":
/*!***************************!*\
  !*** ./src/Renderer2D.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Renderer2D)\n/* harmony export */ });\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"./src/const.js\");\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\n/* harmony import */ var _Renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Renderer.js */ \"./src/Renderer.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar Renderer2D = /*#__PURE__*/function (_Renderer) {\n  _inherits(Renderer2D, _Renderer);\n  var _super = _createSuper(Renderer2D);\n  function Renderer2D(woop, canvas, field_of_view, pixel_scale) {\n    var _this;\n    _classCallCheck(this, Renderer2D);\n    _this = _super.call(this, woop, canvas, '2D', field_of_view, pixel_scale);\n    //common function\n    _defineProperty(_assertThisInitialized(_this), \"draw_background_2D\", function (color) {\n      _this.context.fillStyle = _this.get_color(color, 1, true);\n      _this.context.fillRect(0, 0, _this.canvas.width, _this.canvas.height);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_cursor_2D\", function (x, y, cursor, color, alpha) {\n      _this.context.strokeStyle = _this.context.fillStyle = _this.get_color(color, alpha, true);\n      _this.context.fillStyle = _this.context.fillStyle = _this.get_color(color, alpha, true);\n      _this.context.beginPath();\n      switch (cursor) {\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.CURSORS.ARROW:\n          _this.context.moveTo(x, y);\n          _this.context.lineTo(x + 16, y + 6);\n          _this.context.lineTo(x + 6, y + 16);\n          break;\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.CURSORS.GRAB:\n          _this.context.moveTo(x, y - 8);\n          _this.context.lineTo(x, y + 8);\n          _this.context.moveTo(x - 8, y);\n          _this.context.lineTo(x + 8, y);\n          break;\n      }\n      _this.context.stroke();\n      _this.context.fill();\n    });\n    //editor function\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_point_2D\", function (x, y, stroke_color, stroke_alpha, fill_color, fill_alpha, radius, stroke_size) {\n      var offset_x = _this.get_from_data_sets(\"editor\", \"pixel_x_offset\");\n      var offset_y = _this.get_from_data_sets(\"editor\", \"pixel_y_offset\");\n      var grid_scale = _this.get_from_data_sets(\"editor\", \"grid_scale\");\n      _this.context.strokeStyle = _this.get_color(stroke_color, stroke_alpha, true);\n      _this.context.fillStyle = _this.get_color(fill_color, fill_alpha, true);\n      _this.context.lineWidth = stroke_size;\n      _this.context.beginPath();\n      _this.context.arc(x * grid_scale - offset_x, y * -1 * grid_scale - offset_y, radius, 0, _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pi2);\n      _this.context.stroke();\n      _this.context.fill();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_line_2D\", function (start_x, start_y, end_x, end_y, color, alpha, size) {\n      var offset_x = _this.get_from_data_sets(\"editor\", \"pixel_x_offset\");\n      var offset_y = _this.get_from_data_sets(\"editor\", \"pixel_y_offset\");\n      var grid_scale = _this.get_from_data_sets(\"editor\", \"grid_scale\");\n      _this.context.beginPath();\n      _this.context.fillStyle = \"rgba( 0, 0, 0, 0 )\";\n      _this.context.strokeStyle = _this.get_color(color, alpha, true);\n      _this.context.lineWidth = size;\n      _this.context.moveTo(start_x * grid_scale - offset_x, start_y * -1 * grid_scale - offset_y);\n      _this.context.lineTo(end_x * grid_scale - offset_x, end_y * -1 * grid_scale - offset_y);\n      _this.context.stroke();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_box_2D\", function (top_left_x, top_left_y, bottom_right_x, bottom_right_y, color, alpha, size) {\n      var offset_x = _this.get_from_data_sets(\"editor\", \"pixel_x_offset\");\n      var offset_y = _this.get_from_data_sets(\"editor\", \"pixel_y_offset\");\n      var grid_scale = _this.get_from_data_sets(\"editor\", \"grid_scale\");\n      _this.context.fillStyle = \"rgba( 0, 0, 0, 0 )\";\n      _this.context.strokeStyle = _this.get_color(color, alpha, true);\n      _this.context.lineWidth = size;\n      _this.context.strokeRect(top_left_x * grid_scale - offset_x, top_left_y * -1 * grid_scale - offset_y, bottom_right_x * grid_scale - offset_x - (top_left_x * grid_scale - offset_x), bottom_right_y * -1 * grid_scale - offset_y - (top_left_y * -1 * grid_scale - offset_y));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_text_2D\", function (x, y, text) {\n      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"white\";\n      var size = arguments.length > 4 ? arguments[4] : undefined;\n      _this.context.fillStyle = _this.get_color(color, 1, true);\n      _this.context.font = size.toString() + \"px Arial\";\n      _this.context.fillText(text, x, y);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_player_2D\", function (player, color) {\n      var offset_x = _this.get_from_data_sets(\"editor\", \"pixel_x_offset\");\n      var offset_y = _this.get_from_data_sets(\"editor\", \"pixel_y_offset\");\n      var grid_scale = _this.get_from_data_sets(\"editor\", \"grid_scale\");\n      var player_position_x = _this.woop.player.position.x * grid_scale - offset_x;\n      var player_position_y = _this.woop.player.position.y * -1 * grid_scale - offset_y;\n      var player_horizontal_angle = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_this.woop.player.horizontal_angle * -1);\n      var fov_line_1 = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_this.woop.player.horizontal_angle * -1 + _this.horizontal_fov / 2);\n      var fov_line_2 = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_this.woop.player.horizontal_angle * -1 - _this.horizontal_fov / 2);\n\n      //player position\n      _this.draw_editor_point_2D(_this.woop.player.position.x, _this.woop.player.position.y, color, 1, color, .5, 4, 1);\n\n      //direction line\n      _this.context.beginPath();\n      _this.context.lineWidth = 4;\n      _this.context.strokeStyle = _this.get_color(color, 1, true);\n      _this.context.fillStyle = _this.get_color(color, .5, true);\n      _this.context.moveTo(Math.round(player_position_x + 4 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(player_horizontal_angle)), Math.round(player_position_y + 4 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(player_horizontal_angle)));\n      _this.context.lineTo(Math.round(player_position_x + 20 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(player_horizontal_angle)), Math.round(player_position_y + 20 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(player_horizontal_angle)));\n      _this.context.stroke();\n\n      //field of view lines\n      _this.context.lineWidth = 1;\n      _this.context.strokeStyle = _this.get_color(\"green\", 1, true);\n      _this.context.fillStyle = _this.get_color(\"green\", .5, true);\n      _this.context.beginPath();\n      _this.context.moveTo(Math.round(player_position_x + 4 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(fov_line_1)), Math.round(player_position_y + 4 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(fov_line_1)));\n      _this.context.lineTo(Math.round(player_position_x + 500 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(fov_line_1)), Math.round(player_position_y + 500 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(fov_line_1)));\n      _this.context.stroke();\n      _this.context.beginPath();\n      _this.context.strokeStyle = _this.get_color(\"green\", 1, true);\n      _this.context.fillStyle = _this.get_color(\"green\", .5, true);\n      _this.context.moveTo(Math.round(player_position_x + 4 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(fov_line_2)), Math.round(player_position_y + 4 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(fov_line_2)));\n      _this.context.lineTo(Math.round(player_position_x + 500 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(fov_line_2)), Math.round(player_position_y + 500 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(fov_line_2)));\n      _this.context.stroke();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_grid_2D\", function () {\n      var offset_x = _this.get_from_data_sets(\"editor\", \"pixel_x_offset\");\n      var offset_y = _this.get_from_data_sets(\"editor\", \"pixel_y_offset\");\n      var screen_step_x = Math.ceil(_this.canvas.width / _this.woop.editor.ceil_pixel_size());\n      var screen_step_y = Math.ceil(_this.canvas.height / _this.woop.editor.ceil_pixel_size());\n      var pos_x_offset = _this.woop.editor.grid_pos.x;\n      var pos_y_offset = _this.woop.editor.grid_pos.y * -1;\n      var pixel_grid_x_offset = offset_x % _this.woop.editor.ceil_pixel_size();\n      var pixel_grid_y_offset = offset_y % _this.woop.editor.ceil_pixel_size();\n      var ceil_x_offset = Math.floor(pos_x_offset / _this.woop.editor.unit_by_ceil);\n      var ceil_y_offset = Math.floor(pos_y_offset / _this.woop.editor.unit_by_ceil) * -1;\n      var zero_lines = [];\n      _this.context.beginPath();\n      _this.context.strokeStyle = \"rgba( 120, 120, 120, 1 )\";\n      _this.context.fillStyle = \"rgba( 255, 255, 255, 1 )\";\n      _this.context.lineWidth = 1;\n      _this.context.font = \"6px ARIAL\";\n      _this.context.fillText(\"x\", 30, 20);\n      _this.context.fillText(\"y\", 20, 30);\n      for (var x = 0; x <= screen_step_x; x++) {\n        if (x > 1) {\n          _this.context.fillText((x + ceil_x_offset) * _this.woop.editor.unit_by_ceil, x * _this.woop.editor.ceil_pixel_size() - pixel_grid_x_offset, 20);\n        }\n        if (0 !== Math.ceil((x + ceil_x_offset) * _this.woop.editor.unit_by_ceil)) {\n          _this.context.moveTo(x * _this.woop.editor.ceil_pixel_size() - pixel_grid_x_offset, 0);\n          _this.context.lineTo(x * _this.woop.editor.ceil_pixel_size() - pixel_grid_x_offset, _this.canvas.height);\n        } else {\n          zero_lines.push([x * _this.woop.editor.ceil_pixel_size() - pixel_grid_x_offset, 0, x * _this.woop.editor.ceil_pixel_size() - pixel_grid_x_offset, _this.canvas.height]);\n        }\n      }\n      for (var y = 0; y <= screen_step_y; y++) {\n        if (y > 1) {\n          _this.context.fillText((y * -1 + ceil_y_offset) * _this.woop.editor.unit_by_ceil, 20, y * _this.woop.editor.ceil_pixel_size() - pixel_grid_y_offset);\n        }\n        if (0 !== Math.ceil((y * -1 + ceil_y_offset) * _this.woop.editor.unit_by_ceil)) {\n          _this.context.moveTo(0, y * _this.woop.editor.ceil_pixel_size() - pixel_grid_y_offset);\n          _this.context.lineTo(_this.canvas.width, y * _this.woop.editor.ceil_pixel_size() - pixel_grid_y_offset);\n        } else {\n          zero_lines.push([0, y * _this.woop.editor.ceil_pixel_size() - pixel_grid_y_offset, _this.canvas.width, y * _this.woop.editor.ceil_pixel_size() - pixel_grid_y_offset]);\n        }\n      }\n      _this.context.stroke();\n      if (zero_lines.length > 0) {\n        _this.context.beginPath();\n        _this.context.lineWidth = 2;\n        _this.context.strokeStyle = \"rgba( 120, 0 , 0, 1 )\";\n        zero_lines.forEach(function (p) {\n          _this.context.moveTo(p[0], p[1]);\n          _this.context.lineTo(p[2], p[3]);\n        });\n        _this.context.stroke();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_sector_in_field_of_view_2D\", function (bsp_tree) {\n      bsp_tree.render_nodes(_this.woop.player, _this.draw_editor_sub_sector_2D);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_bsp_node_2D\", function (bsp_node) {\n      _this.draw_editor_box_2D(bsp_node.right_bound_box.top_left.x, bsp_node.right_bound_box.top_left.y, bsp_node.right_bound_box.bottom_right.x, bsp_node.right_bound_box.bottom_right.y, \"dark green\", .5, 2);\n      _this.draw_editor_box_2D(bsp_node.left_bound_box.top_left.x, bsp_node.left_bound_box.top_left.y, bsp_node.left_bound_box.bottom_right.x, bsp_node.left_bound_box.bottom_right.y, \"dark red\", .5, 2);\n      _this.draw_editor_line_2D(bsp_node.partition_line.start.x, bsp_node.partition_line.start.y, bsp_node.partition_line.end.x, bsp_node.partition_line.end.y, \"dark yellow\", 1, 2);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_bound_box_2D\", function (bound_box) {\n      _this.draw_editor_box_2D(bound_box.top_left.x, bound_box.top_left.y, bound_box.bottom_right.x, bound_box.bottom_right.y, \"dark green\", .5, 2);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_editor_sub_sector_2D\", function (sub_sector) {\n      for (var i = 0; i < sub_sector.segments.length; i++) {\n        //seg are not facing player\n        var debug_segment = [330];\n        var segment = sub_sector.segments[i];\n        var angle_start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].point_to_angle(_this.woop.player.position, sub_sector.segments[i].edge.vertices[0]);\n        var angle_end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].point_to_angle(_this.woop.player.position, sub_sector.segments[i].edge.vertices[1]);\n        var angle_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(angle_start - angle_end, 0, 360, true, false);\n        if (angle_span > 180) {\n          continue;\n        }\n        var x1_angle = angle_start - _this.woop.player.horizontal_angle;\n        var angle_start_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(x1_angle + _this.woop.renderer.demi_horizontal_fov, 0, 360, true, false);\n        if (angle_start_span > angle_span + _this.woop.renderer.horizontal_fov) {\n          continue;\n        }\n        var x2_angle = angle_end - _this.woop.player.horizontal_angle;\n        var angle_end_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_this.woop.renderer.demi_horizontal_fov - x2_angle, 0, 360, true, false);\n        if (angle_end_span > angle_span + _this.woop.renderer.horizontal_fov) {\n          continue;\n        }\n        _this.add_color(sub_sector.id, _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].random_int_range(100, 255), _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].random_int_range(100, 255), _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].random_int_range(100, 255));\n        _this.draw_editor_line(sub_sector.segments[i].edge.vertices[0].x, sub_sector.segments[i].edge.vertices[0].y, sub_sector.segments[i].edge.vertices[1].x, sub_sector.segments[i].edge.vertices[1].y, sub_sector.id, 1, 4);\n        var from = [Math.round((segment.vertices[0].x + segment.vertices[1].x) / 2), Math.round((segment.vertices[0].y + segment.vertices[1].y) / 2)];\n        var to = [Math.round(from[0] + 16 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_cos(segment.angle + 90)), Math.round(from[1] + 16 * _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookup_sin(segment.angle + 90))];\n        _this.draw_editor_line(from[0], from[1], to[0], to[1], sub_sector.id, 1, 4);\n        if (debug_segment.includes(sub_sector.segments[i].id)) {\n          _this.woop.debbuger.update_data(\"segment_\" + sub_sector.segments[i].id, {\n            segment: sub_sector.segments[i]\n          });\n        }\n      }\n    });\n    //game function\n    _defineProperty(_assertThisInitialized(_this), \"draw_game_pixel_2D\", function (x, y, color, alpha) {\n      if (x < 0 || x > _this.internal_width - 1) {\n        return;\n      }\n      if (y < 0 || y > _this.internal_height - 1) {\n        return;\n      }\n      _this.context.fillStyle = _this.get_color(color, 1, true);\n      _this.context.fillRect(x * _this.pixel_scale, y * _this.pixel_scale, _this.pixel_scale, _this.pixel_scale);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_game_vertical_line_2D\", function (x, start_y, end_y, texture, light) {\n      if (x < 0 || x > _this.internal_width) {\n        return;\n      }\n      for (var y = start_y; y <= end_y; y++) {\n        if (y < 0 || y > _this.internal_height) {\n          continue;\n        }\n        if (_this.screen_space.pixel_has_space(x, y)) {\n          var color = texture;\n          _this.draw_game_pixel(x, y, color, 1);\n          _this.screen_space.fill_pixel(x, y);\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_game_sector_in_field_of_view_2D\", function (bsp_tree) {\n      _this.screen_space.init();\n      //bsp_tree.render_nodes( this.woop.player, this.draw_game_sub_sector_2D, this.screen_space.is_full )\n      var result = bsp_tree.get_subsectors_to_render(_this.woop.player, _this.screen_space.is_full);\n      _this.woop.player.floor_hight = result.player_sector.floor.height;\n      for (var i = 0; i < result.subsectors.length; i++) {\n        _this.draw_game_sub_sector_2D(result.subsectors[i]);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_game_sub_sector_2D\", function (sub_sector) {\n      for (var i = 0; i < sub_sector.segments.length && _this.screen_space.has_space(); i++) {\n        //segment are not facing player\n        var angle_start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].point_to_angle(_this.woop.player.position, sub_sector.segments[i].edge.vertices[0]);\n        var angle_end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].point_to_angle(_this.woop.player.position, sub_sector.segments[i].edge.vertices[1]);\n        var angle_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(angle_start - angle_end, 0, 360, true, false);\n        if (angle_span > 180) {\n          continue;\n        }\n\n        //segment are not in field of view\n        var x1_angle = angle_start - _this.woop.player.horizontal_angle;\n        var angle_start_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(x1_angle + _this.woop.renderer.demi_horizontal_fov, 0, 360, true, false);\n        if (angle_start_span > _this.woop.renderer.horizontal_fov) {\n          if (angle_start_span >= angle_span + _this.woop.renderer.horizontal_fov) {\n            continue;\n          }\n          //segments are clipped\n          x1_angle = _this.woop.renderer.horizontal_fov;\n        }\n        var x2_angle = angle_end - _this.woop.player.horizontal_angle;\n        var angle_end_span = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_range(_this.woop.renderer.demi_horizontal_fov - x2_angle, 0, 360, true, false);\n        if (angle_end_span > _this.woop.renderer.horizontal_fov) {\n          if (angle_end_span >= angle_span + _this.woop.renderer.horizontal_fov) {\n            continue;\n          }\n          //segments are clipped\n          x2_angle = -_this.woop.renderer.horizontal_fov;\n        }\n        var x1_to_screen = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_to_screen_x(x1_angle, _this.screen_distance, _this.demi_internal_width);\n        var x2_to_screen = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].angle_to_screen_x(x2_angle, _this.screen_distance, _this.demi_internal_width);\n        var x1 = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].value_range(x1_to_screen, 0, _this.internal_width - 1);\n        var x2 = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].value_range(x2_to_screen, 0, _this.internal_width - 1);\n        var debug_segment = [];\n        var debug_data = {};\n\n        //screen buffer checks\n        if (_this.screen_space.horizontal_line_has_space(x1, x2)) {\n          for (var x = x1; x <= x2; x++) {\n            if (_this.screen_space.vertical_line_has_space(x)) {\n              var emptiness_end_at = _this.screen_space.get_empty_horizontal_range(x);\n              _this.draw_game_edge(sub_sector.segments[i], angle_start, x1, x2, x, emptiness_end_at);\n              x = emptiness_end_at;\n            }\n          }\n        }\n        if (debug_segment.includes(sub_sector.segments[i].id)) {\n          _this.woop.debbuger.update_data(\"screen_segment_\" + sub_sector.segments[i].id, debug_data);\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"draw_game_edge_2D\", function (segment, angle_start, x_start, x_end, range_x_star, range_x_end) {\n      var debug_segment = [330];\n      var is_solid = segment.edge.attributes.is_solid;\n      var is_portal = segment.edge.attributes.is_portal;\n      var right_edge_side = segment.edge.right;\n      var left_edge_side = segment.edge.left;\n      var right_sector = right_edge_side.sector;\n      var left_sector = left_edge_side ? left_edge_side.sector : false;\n      var upper_texture = false;\n      var middle_texture = right_edge_side.textures.middle;\n      var lower_texture = false;\n      var celling_texture = right_sector.celling.texture;\n      var floor_texture = right_sector.floor.texture;\n      var edge_light = right_edge_side.light;\n      var floor_light = right_sector.floor.light;\n      var celling_light = right_sector.celling.light;\n      var relative_celling_height = right_sector.celling.height - _this.woop.player.position.z;\n      var relative_upper_height = relative_celling_height;\n      var relative_low_height = right_sector.floor.height - _this.woop.player.position.z;\n      var relative_floor_height = relative_low_height;\n      if (left_sector) {\n        if (right_sector.celling.height != left_sector.celling.height) {\n          if (right_sector.celling.height > left_sector.celling.height) {\n            relative_celling_height = right_sector.celling.height - _this.woop.player.position.z;\n            relative_upper_height = left_sector.celling.height - _this.woop.player.position.z;\n            upper_texture = right_edge_side.textures.upper;\n          } else {\n            relative_celling_height = left_sector.celling.height - _this.woop.player.position.z;\n            relative_upper_height = right_sector.celling.height - _this.woop.player.position.z;\n            upper_texture = left_edge_side.textures.upper;\n          }\n          if (right_sector.floor.height < left_sector.floor.height) {\n            relative_low_height = left_sector.floor.height - _this.woop.player.position.z;\n            relative_floor_height = right_sector.floor.height - _this.woop.player.position.z;\n            lower_texture = right_edge_side.textures.low;\n          } else {\n            relative_low_height = right_sector.floor.height - _this.woop.player.position.z;\n            relative_floor_height = left_sector.floor.height - _this.woop.player.position.z;\n            lower_texture = left_edge_side.textures.low;\n          }\n        }\n      }\n      var upper_edge_is_draw = !!(upper_texture !== false);\n      var middle_edge_is_draw = !!(middle_texture !== false);\n      var lower_edge_is_draw = !!(lower_texture !== false);\n      var celling_is_draw = !!(celling_texture !== false);\n      var floor_is_draw = !!(floor_texture !== false);\n      if (debug_segment.includes(segment.id)) {\n        _this.woop.debbuger.update_data(\"segment_\" + segment.id, {\n          is_solid: is_solid,\n          is_portal: is_portal,\n          display: {\n            upper_edge_is_draw: upper_edge_is_draw,\n            middle_edge_is_draw: middle_edge_is_draw,\n            lower_edge_is_draw: lower_edge_is_draw,\n            celling_is_draw: celling_is_draw,\n            floor_is_draw: floor_is_draw\n          }\n        });\n      }\n      _this.draw_text(x_start * _this.pixel_scale, (edge_upper_y - 20) * _this.pixel_scale, segment.id.toString(), upper_texture, 18);\n      if (!upper_edge_is_draw && !middle_edge_is_draw && !lower_edge_is_draw && !celling_is_draw && !floor_is_draw) {\n        return;\n      }\n      var edge_normal = segment.edge.angle + 90;\n      var offset_angle = edge_normal - angle_start;\n      var hypotenuse = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].distance(_this.woop.player.position, segment.edge.vertices[0]);\n      var distance = hypotenuse * Math.cos(_WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degrees_to_radians(offset_angle));\n      var scale_start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(x_start, edge_normal, distance, _this.screen_distance, _this.woop.player.horizontal_angle);\n      var scale_end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(x_end, edge_normal, distance, _this.screen_distance, _this.woop.player.horizontal_angle);\n      var scale_step = (scale_end - scale_start) / (x_end - x_start);\n      var edge_celling_y = _this.demi_internal_height - relative_celling_height * scale_start;\n      var edge_celling_step = -scale_step * relative_celling_height;\n      var edge_upper_y = _this.demi_internal_height - relative_upper_height * scale_start;\n      var edge_upper_step = -scale_step * relative_upper_height;\n      var edge_low_y = _this.demi_internal_height - relative_low_height * scale_start;\n      var edge_low_step = -scale_step * relative_low_height;\n      var edge_floor_y = _this.demi_internal_height - relative_floor_height * scale_start;\n      var edge_floor_step = -scale_step * relative_floor_height;\n      for (var x = x_start; x <= x_end; x++) {\n        if (x < range_x_star || x > range_x_end) {\n          continue;\n        }\n        var celling_y = edge_celling_y + edge_celling_step * (x - x_start);\n        var upper_y = edge_upper_y + edge_upper_step * (x - x_start);\n        var low_y = edge_low_y + edge_low_step * (x - x_start);\n        var floor_y = edge_floor_y + edge_floor_step * (x - x_start);\n        if (middle_edge_is_draw) {\n          var y1 = upper_edge_is_draw ? upper_y : celling_y;\n          var y2 = lower_edge_is_draw && floor_y > low_y ? low_y : floor_y;\n          _this.draw_game_vertical_line(x, Math.round(y1), Math.round(y2), middle_texture);\n          _this.screen_space.fill_vertical_line(x, Math.round(y1), Math.round(y2));\n        }\n        if (upper_edge_is_draw) {\n          _this.draw_game_vertical_line(x, Math.round(celling_y), Math.round(upper_y), upper_texture);\n          _this.screen_space.fill_vertical_line(x, Math.round(celling_y), Math.round(upper_y));\n        }\n        if (celling_is_draw) {\n          var y_start = _this.screen_space.get_empty_vertical_range(x, Math.round(celling_y), 0);\n          //this.draw_game_vertical_line( x, y_start, Math.round( celling_y ), celling_texture )\n          //this.screen_space.fill_vertical_line( x, y_start, Math.round( celling_y ) )\n        }\n\n        if (lower_edge_is_draw) {\n          _this.draw_game_vertical_line(x, Math.round(low_y), Math.round(floor_y), lower_texture);\n          _this.screen_space.fill_vertical_line(x, Math.round(low_y), Math.round(floor_y));\n        }\n        if (floor_is_draw) {\n          _this.draw_game_vertical_line(x, Math.round(floor_y), _this.internal_height - 1, floor_texture);\n          //this.screen_space.fill_vertical_line( x, Math.round( floor_y ), this.internal_height -1 )\n        }\n      }\n    });\n    return _this;\n  }\n  return _createClass(Renderer2D);\n}(_Renderer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\n\n//# sourceURL=webpack://woop/./src/Renderer2D.js?");

/***/ }),

/***/ "./src/ScreenSpace.js":
/*!****************************!*\
  !*** ./src/ScreenSpace.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SCREEN_STATUS\": () => (/* binding */ SCREEN_STATUS),\n/* harmony export */   \"default\": () => (/* binding */ ScreenSpace)\n/* harmony export */ });\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar SCREEN_STATUS = {\n  EMPTY: 0,\n  PARTIAL: 1,\n  FULL: 2\n};\nvar ScreenSpace = /*#__PURE__*/_createClass(function ScreenSpace(screen_width, screen_height) {\n  var _this = this;\n  _classCallCheck(this, ScreenSpace);\n  _defineProperty(this, \"init\", function () {\n    _this.screen = Array(_this.width).fill().map(function () {\n      return [SCREEN_STATUS.EMPTY, Array(_this.height).fill().map(function () {\n        return SCREEN_STATUS.EMPTY;\n      })];\n    });\n  });\n  _defineProperty(this, \"fill_pixel\", function (x, y) {\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    y = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(y, 0, _this.height - 1);\n    _this.screen[x][1][y] = SCREEN_STATUS.FULL;\n    _this.update_vertical_line(x);\n  });\n  _defineProperty(this, \"fill_vertical_line\", function (x) {\n    var y_start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y_end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.height - 1;\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    y_start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(y_start, 0, _this.height - 1);\n    y_end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(y_end, 0, _this.height - 1);\n    if (y_start === 0 && y_end === _this.height - 1) {\n      _this.screen[x] = [SCREEN_STATUS.FULL, Array(_this.height).fill(SCREEN_STATUS.FULL)];\n      return;\n    }\n    for (var y = y_start; y <= y_end; y++) {\n      _this.screen[x][1][y] = SCREEN_STATUS.FULL;\n    }\n    _this.update_vertical_line(x);\n  });\n  _defineProperty(this, \"fill_horizontal_line\", function () {\n    var x_start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var x_end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.width - 1;\n    x_start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x_start, 0, _this.width - 1);\n    x_end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x_end, 0, _this.width - 1);\n    for (var x = x_start; x <= x_end; x++) {\n      _this.screen[x] = [SCREEN_STATUS.FULL, Array(_this.height).fill(SCREEN_STATUS.FULL)];\n    }\n  });\n  _defineProperty(this, \"get_empty_horizontal_range\", function (x) {\n    var x_max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.width - 1;\n    var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    if (![-1, 1].includes(direction)) {\n      console.log('get_empty_vertical_range : invalid direction');\n      return x;\n    }\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    x_max = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x_max, 0, _this.width - 1);\n    if (_this.vertical_is_full(x)) {\n      return 0;\n    }\n    while (x !== x_max && _this.vertical_line_has_space(x)) {\n      x = x + direction;\n    }\n    return x;\n  });\n  _defineProperty(this, \"get_empty_vertical_range\", function (x, y, y_max) {\n    var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    if (![-1, 1].includes(direction)) {\n      console.log('get_empty_vertical_range : invalid direction');\n      return y;\n    }\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    y = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(y, 0, _this.height - 1);\n    y_max = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(y_max, 0, _this.height - 1);\n    if (_this.pixel_is_full(x, y)) {\n      return 0;\n    }\n    while (y !== y_max + direction && _this.pixel_is_full(x, y)) {\n      y = y + direction;\n    }\n    return y;\n  });\n  _defineProperty(this, \"has_space\", function () {\n    for (var x = 0; x < _this.width; x++) {\n      if (_this.screen[x][0] === SCREEN_STATUS.FULL) {\n        continue;\n      }\n      return true;\n    }\n    return false;\n  });\n  _defineProperty(this, \"is_full\", function () {\n    return !_this.has_space();\n  });\n  _defineProperty(this, \"horizontal_line_has_space\", function (value_1, value_2) {\n    var start = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(Math.min(value_1, value_2), 0, _this.width - 1);\n    var end = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(Math.min(value_1, value_2), 0, _this.width - 1);\n    for (var x = start; x <= end; x++) {\n      if (_this.screen[x][0] === SCREEN_STATUS.FULL) {\n        continue;\n      }\n      return true;\n    }\n    return false;\n  });\n  _defineProperty(this, \"horizontal_line_is_full\", function (value_1, value_2) {\n    return !_this.horizontal_line_has_space(value_1, value_2);\n  });\n  _defineProperty(this, \"vertical_line_has_space\", function (x) {\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    if (_this.screen[x][0] === SCREEN_STATUS.FULL) {\n      return false;\n    }\n    return true;\n  });\n  _defineProperty(this, \"vertical_is_full\", function (x) {\n    return !_this.vertical_line_has_space(x);\n  });\n  _defineProperty(this, \"update_vertical_line\", function (x) {\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    if (!_this.screen[x][1].includes(0)) {\n      _this.screen[x][0] = SCREEN_STATUS.FULL;\n    } else if (_this.screen[x][1].includes(1)) {\n      _this.screen[x][0] = SCREEN_STATUS.PARTIAL;\n    } else {\n      _this.screen[x][0] = SCREEN_STATUS.EMPTY;\n    }\n  });\n  _defineProperty(this, \"pixel_has_space\", function () {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.width - 1;\n    x = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(x, 0, _this.width - 1);\n    y = _WoopMath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].value_range(y, 0, _this.height - 1);\n    return _this.screen[x][1][y] === SCREEN_STATUS.EMPTY ? true : false;\n  });\n  _defineProperty(this, \"pixel_is_full\", function () {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.width - 1;\n    return !_this.pixel_has_space(x, y);\n  });\n  this.screen = null;\n  this.width = screen_width;\n  this.height = screen_height;\n  this.init();\n});\n\n\n//# sourceURL=webpack://woop/./src/ScreenSpace.js?");

/***/ }),

/***/ "./src/WadData.js":
/*!************************!*\
  !*** ./src/WadData.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WadData)\n/* harmony export */ });\n/* harmony import */ var _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type/Int2DVertex.js */ \"./src/type/Int2DVertex.js\");\n/* harmony import */ var _type_Int3DVertex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type/Int3DVertex.js */ \"./src/type/Int3DVertex.js\");\n/* harmony import */ var _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BSPTree.js */ \"./src/BSPTree.js\");\n/* harmony import */ var _WoopMath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WoopMath.js */ \"./src/WoopMath.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\nvar WadData = /*#__PURE__*/function () {\n  function WadData(woop, things, linedefs, sidedef, vertices, segs, ssectors, nodes, sectors, reject, blockmap) {\n    _classCallCheck(this, WadData);\n    this.woop = woop;\n    this.cache = [];\n    this.things = things;\n    this.linedefs = linedefs;\n    this.sidedef = sidedef;\n    this.vertices = vertices;\n    this.segs = segs;\n    this.ssectors = ssectors;\n    this.nodes = nodes;\n    this.sectors = sectors;\n    this.reject = reject;\n    this.blockmap = blockmap;\n  }\n  _createClass(WadData, [{\n    key: \"get_boundary\",\n    value: function get_boundary() {\n      if (typeof this.cache.boundary !== \"undefined\") {\n        return this.cache.boundary;\n      }\n      var top_right = _toConsumableArray(this.vertices[0]);\n      var bottom_left = _toConsumableArray(this.vertices[0]);\n      this.vertices.forEach(function (vertex) {\n        if (vertex[0] < top_right[0]) {\n          top_right[0] = vertex[0];\n        }\n        if (vertex[1] > top_right[1]) {\n          top_right[1] = vertex[1];\n        }\n        if (vertex[0] > bottom_left[0]) {\n          bottom_left[0] = vertex[0];\n        }\n        if (vertex[1] < bottom_left[1]) {\n          bottom_left[1] = vertex[1];\n        }\n      });\n      this.cache.boundary = [new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](top_right[0], top_right[1]), new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bottom_left[0], bottom_left[1])];\n      return this.cache.boundary;\n    }\n  }, {\n    key: \"get_size\",\n    value: function get_size() {\n      if (typeof this.cache.size !== \"undefined\") {\n        return this.cache.size;\n      }\n      var boundary = this.get_boundary();\n      this.cache.size = new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](boundary[0].x - boundary[1].x, boundary[0].y - boundary[1].y);\n      return this.cache.size;\n    }\n  }, {\n    key: \"get_player_start\",\n    value: function get_player_start() {\n      var things = this.get_things();\n      return {\n        position: new _type_Int3DVertex_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](things[0].position.x, things[0].position.y, 0),\n        horizontal_angle: things[0].angle,\n        vertical_angle: 0\n      };\n    }\n  }, {\n    key: \"get_things\",\n    value: function get_things() {\n      if (typeof this.cache.things !== \"undefined\") {\n        return this.cache.things;\n      }\n      this.cache.things = [];\n      for (var i = 0; i < this.things.length; i++) {\n        this.cache.things.push({\n          position: new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.things[i][0], this.things[i][1]),\n          angle: this.things[i][2],\n          type: this.things[i][3],\n          flags: this.things[i][4]\n        });\n      }\n      return this.cache.things;\n    }\n  }, {\n    key: \"get_bsp_tree\",\n    value: function get_bsp_tree() {\n      if (typeof this.cache.nodes !== \"undefined\") {\n        return this.cache.nodes;\n      }\n      var sub_sectors = this.get_sub_sectors();\n      this.cache.nodes = [];\n      for (var i = 0; i < this.nodes.length; i++) {\n        this.cache.nodes.push(new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.BSPNode(i, this.nodes[i][6] < 0 ? sub_sectors[0x8000 + this.nodes[i][6]] : this.cache.nodes[this.nodes[i][6]], this.nodes[i][7] < 0 ? sub_sectors[0x8000 + this.nodes[i][7]] : this.cache.nodes[this.nodes[i][7]], new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.BoundBox(new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.nodes[i][4][2], this.nodes[i][4][0]), new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.nodes[i][4][3], this.nodes[i][4][1])), new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.BoundBox(new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.nodes[i][5][2], this.nodes[i][5][0]), new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.nodes[i][5][3], this.nodes[i][5][1])), new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.PartitionLine(new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.nodes[i][0], this.nodes[i][1]), new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.nodes[i][0] + this.nodes[i][2], this.nodes[i][1] + this.nodes[i][3]), this.nodes[i][2], this.nodes[i][3])));\n      }\n      return new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.BSPTree(this.woop, this.cache.nodes);\n    }\n  }, {\n    key: \"get_sub_sectors\",\n    value: function get_sub_sectors() {\n      if (typeof this.cache.ssectors !== \"undefined\") {\n        return this.cache.ssectors;\n      }\n      var segments = this.get_segments();\n      this.cache.ssectors = [];\n      for (var i = 0; i < this.ssectors.length; i++) {\n        var slice = [];\n        for (var i2 = this.ssectors[i][1]; i2 < this.ssectors[i][1] + this.ssectors[i][0]; i2++) {\n          slice.push(segments[i2]);\n        }\n        this.cache.ssectors.push(new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.SubSector(i, slice));\n      }\n      return this.cache.ssectors;\n    }\n  }, {\n    key: \"get_segments\",\n    value: function get_segments() {\n      if (typeof this.cache.segs !== \"undefined\") {\n        return this.cache.segs;\n      }\n      var vertices = this.get_vertices();\n      var edges = this.get_linedefs();\n      this.cache.segs = [];\n      for (var i = 0; i < this.segs.length; i++) {\n        edges[this.segs[i][3]].set_direction(this.segs[i][4]);\n        edges[this.segs[i][3]].set_angle(_WoopMath_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].binary_angle_to_degree(this.segs[i][2]));\n        this.cache.segs.push(new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.Segment(i, vertices[this.segs[i][0]], vertices[this.segs[i][1]], _WoopMath_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].binary_angle_to_degree(this.segs[i][2]), this.segs[i][5], edges[this.segs[i][3]]));\n      }\n      return this.cache.segs;\n    }\n  }, {\n    key: \"get_vertices\",\n    value: function get_vertices() {\n      if (typeof this.cache.vertices !== \"undefined\") {\n        return this.cache.vertices;\n      }\n      this.cache.vertices = [];\n      for (var i = 0; i < this.vertices.length; i++) {\n        this.cache.vertices.push(new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.vertices[i][0], this.vertices[i][1]));\n      }\n      return this.cache.vertices;\n    }\n  }, {\n    key: \"get_linedefs\",\n    value: function get_linedefs() {\n      if (typeof this.cache.linedefs !== \"undefined\") {\n        return this.cache.linedefs;\n      }\n      var vertices = this.get_vertices();\n      var sidedefs = this.get_sidedefs();\n      this.cache.linedefs = [];\n      for (var i = 0; i < this.linedefs.length; i++) {\n        var right = this.linedefs[i][5] !== -1 ? sidedefs[this.linedefs[i][5]] : false;\n        var left = this.linedefs[i][6] !== -1 ? sidedefs[this.linedefs[i][6]] : false;\n        var attributes = {\n          doom_fag: this.linedefs[i][2],\n          doom_special_type: this.linedefs[i][3],\n          doom_sector_tag: this.linedefs[i][4],\n          is_solid: !(right && left),\n          is_portal: !!(right && left)\n          //TODO detect trigger line\n        };\n\n        this.cache.linedefs.push(new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.Edge(vertices[this.linedefs[i][0]], vertices[this.linedefs[i][1]], 0, 0, right, left, attributes));\n      }\n      return this.cache.linedefs;\n    }\n  }, {\n    key: \"get_sidedefs\",\n    value: function get_sidedefs() {\n      if (typeof this.cache.sidedef !== \"undefined\") {\n        return this.cache.sidedef;\n      }\n      this.cache.sidedef = [];\n      var sector = this.get_sectors();\n      for (var i = 0; i < this.sidedef.length; i++) {\n        this.cache.sidedef.push(new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.EdgeSide(new _type_Int2DVertex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.sidedef[i][0], this.sidedef[i][1]), sector[this.sidedef[i][5]], sector[this.sidedef[i][5]].celling.light, this.sidedef[i][2] !== \"-\" ? this.sidedef[i][2] : false, this.sidedef[i][4] !== \"-\" ? this.sidedef[i][4] : false, this.sidedef[i][3] !== \"-\" ? this.sidedef[i][3] : false, {\n          doom_special_type: this.sidedef[i][5],\n          doom_tag_number: this.sidedef[i][6]\n        }));\n      }\n      return this.cache.sidedef;\n    }\n  }, {\n    key: \"get_sectors\",\n    value: function get_sectors() {\n      if (typeof this.cache.sectors !== \"undefined\") {\n        return this.cache.sectors;\n      }\n      this.cache.sectors = [];\n      for (var i = 0; i < this.sectors.length; i++) {\n        this.cache.sectors.push(new _BSPTree_js__WEBPACK_IMPORTED_MODULE_2__.Sector(i, this.sectors[i][1], this.sectors[i][0], this.sectors[i][3] !== \"-\" ? this.sectors[i][3] : false, this.sectors[i][2] !== \"-\" ? this.sectors[i][2] : false, this.sectors[i][4], this.sectors[i][4]));\n      }\n      return this.cache.sectors;\n    }\n  }]);\n  return WadData;\n}();\n\n\n//# sourceURL=webpack://woop/./src/WadData.js?");

/***/ }),

/***/ "./src/WadLoader.js":
/*!**************************!*\
  !*** ./src/WadLoader.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WadLoader)\n/* harmony export */ });\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"./src/const.js\");\n/* harmony import */ var _WadData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WadData.js */ \"./src/WadData.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar WadLoader = /*#__PURE__*/function () {\n  function WadLoader(woop) {\n    var _this = this;\n    var file_paths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, WadLoader);\n    this.woop = woop;\n    this.cache = [];\n    this.wads = [];\n    this.lumps_count = 0;\n    this.lumps_directory = [];\n    if (file_paths.length > 0) {\n      file_paths.forEach(function (file_path) {\n        _this.add_wad(file_path);\n      });\n    }\n  }\n  _createClass(WadLoader, [{\n    key: \"get_int8\",\n    value: function get_int8(buffer, position) {\n      return new Int8Array(buffer, position, 1)[0];\n    }\n  }, {\n    key: \"get_int16\",\n    value: function get_int16(buffer, position) {\n      return new Int16Array(buffer, position, 1)[0];\n    }\n  }, {\n    key: \"get_int32\",\n    value: function get_int32(buffer, position) {\n      return new Int32Array(buffer, position, 1)[0];\n    }\n\n    //you have not write this, you bastard, please give credit\n  }, {\n    key: \"ascii_decoder\",\n    value: function ascii_decoder(buffer) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var return_string = \"\";\n      var end = buffer.byteLength;\n      if (end - offset < 1) {\n        return return_string;\n      }\n      for (var i = offset; i < end; i++) {\n        var t = buffer[i];\n        if (t <= 0x7F) {\n          return_string += String.fromCharCode(t);\n        } else if (t >= 0xC0 && t < 0xE0) {\n          return_string += String.fromCharCode((t & 0x1F) << 6 | buffer[i] & 0x3F);\n        } else if (t >= 0xE0 && t < 0xF0) {\n          return_string += String.fromCharCode((t & 0xF) << 12 | (buffer[i] & 0x3F) << 6 | buffer[i] & 0x3F);\n        } else if (t >= 0xF0) {\n          var t2 = ((t & 7) << 18 | (buffer[i] & 0x3F) << 12 | (buffer[i] & 0x3F) << 6 | buffer[i] & 0x3F) - 0x10000;\n          return_string += String.fromCharCode(0xD800 + (t2 >> 10));\n          return_string += String.fromCharCode(0xDC00 + (t2 & 0x3FF));\n        }\n      }\n      return return_string;\n    }\n  }, {\n    key: \"read_bytes\",\n    value: function read_bytes(buffer, offset, bytes_length, output_type) {\n      switch (output_type) {\n        case \"int8\":\n          return this.get_int8(buffer, offset);\n          break;\n        case \"int16\":\n          return this.get_int16(buffer, offset);\n          break;\n        case \"int16[4]\":\n          return [this.get_int16(buffer, offset), this.get_int16(buffer, offset + 2), this.get_int16(buffer, offset + 4), this.get_int16(buffer, offset + 6)];\n          break;\n        case \"int32\":\n          return this.get_int32(buffer, offset, 4);\n          break;\n        default:\n          //string\n          return new Uint8Array(buffer, offset, bytes_length);\n      }\n    }\n  }, {\n    key: \"read_1_byte\",\n    value: function read_1_byte(buffer, offset) {\n      var output_type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'int8';\n      return this.read_bytes(buffer, offset, 1, output_type);\n    }\n  }, {\n    key: \"read_2_bytes\",\n    value: function read_2_bytes(buffer, offset) {\n      var output_type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'int16';\n      return this.read_bytes(buffer, offset, 2, output_type);\n    }\n  }, {\n    key: \"read_4_bytes\",\n    value: function read_4_bytes(buffer, offset) {\n      var output_type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'int32';\n      return this.read_bytes(buffer, offset, 4, output_type);\n    }\n  }, {\n    key: \"read_8_bytes\",\n    value: function read_8_bytes(buffer, offset) {\n      var output_type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'int16[4]';\n      return this.read_bytes(buffer, offset, 8, output_type);\n    }\n  }, {\n    key: \"read_string\",\n    value: function read_string(buffer, offset, bytes_length) {\n      var ascii_string = this.read_bytes(buffer, offset, bytes_length);\n      return this.ascii_decoder(ascii_string).replace(/\\x00*/g, \"\");\n    }\n  }, {\n    key: \"add_wad\",\n    value: function add_wad(file_path) {\n      var request = new XMLHttpRequest();\n      request.open('GET', file_path, false);\n      request.overrideMimeType('text\\/plain; charset=x-user-defined');\n      request.send();\n      if (request.status != 200) {\n        console.log(\"couldn't open \" + file_path);\n        return;\n      }\n      console.log(\"adding \" + file_path);\n      var wad_index = this.wads.length;\n      var buffer = Uint8Array.from(request.response, function (c) {\n        return c.charCodeAt(0);\n      }).buffer;\n      var wad = {\n        header: {\n          type: this.read_string(buffer, 0, 4),\n          lump_count: this.read_4_bytes(buffer, 4),\n          init_offset: this.read_4_bytes(buffer, 8)\n        },\n        file_buffer: buffer\n      };\n      if (wad.header.type != \"IWAD\") {\n        if (wad.header.type != \"PWAD\") {\n          console.log(\"Wad file \" + file_path + \" doesn't have IWAD or PWAD id\");\n          return;\n        }\n      }\n      this.wads.push(wad);\n\n      //update lump directory\n      var lump_init_offset = wad.header.init_offset;\n      this.lumps_count += wad.header.lump_count;\n      for (var i = 0; i < wad.header.lump_count; i++) {\n        var lump_p = {};\n        lump_p.wad = wad_index;\n        lump_p.offset = this.read_4_bytes(buffer, lump_init_offset);\n        lump_p.size = this.read_4_bytes(buffer, lump_init_offset + 4);\n        lump_p.name = this.read_string(buffer, lump_init_offset + 8, 8);\n        lump_init_offset += 16;\n        this.lumps_directory.push(lump_p);\n      }\n    }\n  }, {\n    key: \"get_lump_index_by_name\",\n    value: function get_lump_index_by_name(lump_name) {\n      var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      for (var i = this.lumps_count; i--; i >= 0) {\n        if (this.lumps_directory[i].name == lump_name) {\n          if (verbose) {\n            console.log(\"lump \" + lump_name + \" found at index '\" + i + \"' !\");\n          }\n          return i;\n        }\n      }\n      console.log(\"Lump \" + lump_name + \" not found!\");\n      return -1;\n    }\n  }, {\n    key: \"get_lumps_indexes_by_name\",\n    value: function get_lumps_indexes_by_name(lumps_names) {\n      var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var lumps_indexes = [];\n      for (var i = 0; i < this.lumps_count; i++) {\n        var l = lumps_names.indexOf(this.lumps_directory[i].name);\n        if (-1 != l) {\n          if (verbose) {\n            console.log(\"lump \" + lumps_names[l] + \" found at index '\" + i + \"' !\");\n          }\n          lumps_indexes.push(i);\n        }\n      }\n      if (lumps_indexes.length === 0 && verbose) {\n        console.log(\"Lumps not found !\");\n      }\n      return lumps_indexes;\n    }\n  }, {\n    key: \"get_map_data\",\n    value: function get_map_data(map_name) {\n      var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var map_index = this.get_lump_index_by_name(map_name);\n      if (-1 === map_index) {\n        return null;\n      }\n      return new _WadData_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.woop, this.read_things_from_lump(map_index), this.read_lindefs_from_lump(map_index), this.read_sidedef_from_lump(map_index), this.read_vertices_from_lump(map_index), this.read_segs_from_lump(map_index), this.read_ssectors_from_lump(map_index), this.read_nodes_from_lump(map_index), this.read_sectors_from_lump(map_index), this.read_reject_from_lump(map_index), this.read_blockmap_from_lump(map_index));\n    }\n  }, {\n    key: \"read_things_from_lump\",\n    value: function read_things_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.THINGS);\n      var things = [];\n      for (var i = 0; i < lump.byteLength; i = i + 10) {\n        things.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //x position\n        this.read_2_bytes(lump, i + 2, 'int16'),\n        //y position\n        this.read_2_bytes(lump, i + 4, 'int16'),\n        //Angle facing\n        this.read_2_bytes(lump, i + 6, 'int16'),\n        //DoomEd thing type\n        this.read_2_bytes(lump, i + 8, 'int16') //Flags\n        ]);\n      }\n\n      return things;\n    }\n  }, {\n    key: \"read_vertices_from_lump\",\n    value: function read_vertices_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.VERTEXES);\n      var vertices = [];\n      for (var i = 0; i < lump.byteLength; i = i + 4) {\n        vertices.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //x position\n        this.read_2_bytes(lump, i + 2, 'int16') //y position\n        ]);\n      }\n\n      return vertices;\n    }\n  }, {\n    key: \"read_nodes_from_lump\",\n    value: function read_nodes_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.NODES);\n      var nodes = [];\n      for (var i = 0; i < lump.byteLength; i = i + 28) {\n        nodes.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //x coordinate of partition line start\n        this.read_2_bytes(lump, i + 2, 'int16'),\n        //y coordinate of partition line start\n        this.read_2_bytes(lump, i + 4, 'int16'),\n        //Change in x from start to end of partition line\n        this.read_2_bytes(lump, i + 6, 'int16'),\n        //Change in y from start to end of partition line\n        this.read_8_bytes(lump, i + 8, 'int16[4]'),\n        //Right bounding box\n        this.read_8_bytes(lump, i + 16, 'int16[4]'),\n        //Left bounding box\n        this.read_2_bytes(lump, i + 24, 'int16'),\n        //Right child\n        this.read_2_bytes(lump, i + 26, 'int16') //Left child\n        ]);\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"read_ssectors_from_lump\",\n    value: function read_ssectors_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.SSECTORS);\n      var ssectors = [];\n      for (var i = 0; i < lump.byteLength; i = i + 4) {\n        ssectors.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //Seg count\n        this.read_2_bytes(lump, i + 2, 'int16') //First seg index\n        ]);\n      }\n\n      return ssectors;\n    }\n  }, {\n    key: \"read_segs_from_lump\",\n    value: function read_segs_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.SEGS);\n      var segs = [];\n      for (var i = 0; i < lump.byteLength; i = i + 12) {\n        segs.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //Starting vertex index\n        this.read_2_bytes(lump, i + 2, 'int16'),\n        //Ending vertex index\n        this.read_2_bytes(lump, i + 4, 'int16'),\n        //Angle, full circle is -32768 to 32767.\n        this.read_2_bytes(lump, i + 6, 'int16'),\n        //Linedef index\n        this.read_2_bytes(lump, i + 8, 'int16'),\n        //Direction // 0 (same as linedef) or 1 (opposite of linedef)\n        this.read_2_bytes(lump, i + 10, 'int16') //Offset    // distance along linedef to start of seg\n        ]);\n      }\n\n      return segs;\n    }\n  }, {\n    key: \"read_lindefs_from_lump\",\n    value: function read_lindefs_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.LINEDEFS);\n      var lindefs = [];\n      for (var i = 0; i < lump.byteLength; i = i + 14) {\n        lindefs.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //Start Vertex index\n        this.read_2_bytes(lump, i + 2, 'int16'),\n        //End Vertex index\n        this.read_2_bytes(lump, i + 4, 'int16'),\n        //Flags\n        this.read_2_bytes(lump, i + 6, 'int16'),\n        //Special Type\n        this.read_2_bytes(lump, i + 8, 'int16'),\n        //Sector Tag\n        this.read_2_bytes(lump, i + 10, 'int16'),\n        //Front Sidedef index\n        this.read_2_bytes(lump, i + 12, 'int16') //Back Sidedef index\n        ]);\n      }\n\n      return lindefs;\n    }\n  }, {\n    key: \"read_sidedef_from_lump\",\n    value: function read_sidedef_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.SIDEDEFS);\n      var sidedefs = [];\n      for (var i = 0; i < lump.byteLength; i = i + 30) {\n        sidedefs.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //x offset\n        this.read_2_bytes(lump, i + 2, 'int16'),\n        //y offset\n        this.read_string(lump, i + 4, 8),\n        //Name of upper texture\n        this.read_string(lump, i + 12, 8),\n        //Name of lower texture\n        this.read_string(lump, i + 20, 8),\n        //Name of middle texture\n        this.read_2_bytes(lump, i + 28, 'int16') //Sector number this sidedef 'faces'\n        ]);\n      }\n\n      return sidedefs;\n    }\n  }, {\n    key: \"read_sectors_from_lump\",\n    value: function read_sectors_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.SECTORS);\n      var sectors = [];\n      for (var i = 0; i < lump.byteLength; i = i + 26) {\n        sectors.push([this.read_2_bytes(lump, i + 0, 'int16'),\n        //Floor height\n        this.read_2_bytes(lump, i + 2, 'int16'),\n        //Ceiling height\n        this.read_string(lump, i + 4, 8),\n        //Name of floor texture\n        this.read_string(lump, i + 12, 8),\n        //Name of ceiling texture\n        this.read_2_bytes(lump, i + 20, 'int16'),\n        //Light level\n        this.read_2_bytes(lump, i + 22, 'int16'),\n        //Special Type\n        this.read_2_bytes(lump, i + 24, 'int16') //Tag number\n        ]);\n      }\n\n      return sectors;\n    }\n  }, {\n    key: \"read_reject_from_lump\",\n    value: function read_reject_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.REJECT);\n      return lump;\n    }\n  }, {\n    key: \"read_blockmap_from_lump\",\n    value: function read_blockmap_from_lump(map_index) {\n      var lump = this.cache_lump(map_index + _const_js__WEBPACK_IMPORTED_MODULE_0__.DOOM.MAP_LUMPS.BLOCKMAP);\n      return lump;\n    }\n  }, {\n    key: \"cache_lump\",\n    value: function cache_lump(lump_index) {\n      var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (lump_index >= this.lumps_count && verbose) {\n        console(\"lump index is out of range !\");\n      }\n      var wad_index = this.lumps_directory[lump_index].wad;\n      if (\"undefined\" == typeof this.cache[wad_index]) {\n        this.cache[wad_index] = [];\n      }\n      if (!this.cache[wad_index][lump_index]) {\n        this.cache[wad_index][lump_index] = this.wads[wad_index].file_buffer.slice(this.lumps_directory[lump_index].offset, this.lumps_directory[lump_index].offset + this.lumps_directory[lump_index].size);\n      }\n      return this.cache[wad_index][lump_index];\n    }\n  }]);\n  return WadLoader;\n}();\n\n\n//# sourceURL=webpack://woop/./src/WadLoader.js?");

/***/ }),

/***/ "./src/WoopMath.js":
/*!*************************!*\
  !*** ./src/WoopMath.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WoopMath)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar WoopMath = /*#__PURE__*/function () {\n  function WoopMath() {\n    _classCallCheck(this, WoopMath);\n  }\n  _createClass(WoopMath, null, [{\n    key: \"distance\",\n    value: function distance(point_1, point_2) {\n      return Math.round(Math.sqrt(Math.pow(point_2.x - point_1.x, 2) + Math.pow(point_2.y - point_1.y, 2)));\n    }\n  }]);\n  return WoopMath;\n}();\n_defineProperty(WoopMath, \"is_init\", false);\n_defineProperty(WoopMath, \"lookup_tables\", {\n  cos: [],\n  sin: [],\n  x_to_angle: []\n});\n_defineProperty(WoopMath, \"pi\", Math.PI);\n_defineProperty(WoopMath, \"pi2\", 2 * WoopMath.pi);\n_defineProperty(WoopMath, \"piRad\", WoopMath.pi / 180);\n_defineProperty(WoopMath, \"piDeg\", 180 / WoopMath.pi);\n_defineProperty(WoopMath, \"min_scale\", 0.00390625);\n_defineProperty(WoopMath, \"max_scale\", 64);\n_defineProperty(WoopMath, \"init\", function (renderer) {\n  for (var i = 0; i < 360; i++) {\n    WoopMath.lookup_tables.cos[i] = Math.cos(i * WoopMath.piRad);\n    WoopMath.lookup_tables.sin[i] = Math.sin(i * WoopMath.piRad);\n  }\n  for (var _i = 0; _i < renderer.internal_width; _i++) {\n    WoopMath.lookup_tables.x_to_angle[_i] = WoopMath.radians_to_degrees(Math.atan((renderer.demi_internal_width - _i) / renderer.screen_distance));\n  }\n  WoopMath.is_init = true;\n});\n_defineProperty(WoopMath, \"lookup_x_to_angle\", function (value) {\n  if (!WoopMath.is_init) {\n    console.log('WoopMath need to be init ( after the renderer ) for assessing the lookup table function');\n    return null;\n  }\n  return WoopMath.lookup_tables.x_to_angle[value];\n});\n_defineProperty(WoopMath, \"lookup_cos\", function (value) {\n  if (!WoopMath.is_init) {\n    console.log('WoopMath need to be init for assessing the lookup table function');\n    return null;\n  }\n  return WoopMath.lookup_tables.cos[WoopMath.angle_range(value)];\n});\n_defineProperty(WoopMath, \"lookup_sin\", function (value) {\n  if (!WoopMath.is_init) {\n    console.log('WoopMath need to be init for assessing the lookup table function');\n    return null;\n  }\n  return WoopMath.lookup_tables.sin[WoopMath.angle_range(value)];\n});\n//TODO::redo\n_defineProperty(WoopMath, \"scale\", function (x, edge_normal, distance, screen_distance, player_angle) {\n  var x_angle = WoopMath.lookup_x_to_angle(x);\n  var num = screen_distance * Math.cos(WoopMath.degrees_to_radians(edge_normal - x_angle - player_angle));\n  var den = distance * Math.cos(WoopMath.degrees_to_radians(x_angle));\n  var scale = num / den;\n  return Math.min(Math.max(scale, WoopMath.min_scale), WoopMath.max_scale);\n});\n_defineProperty(WoopMath, \"angle_range\", function (angle) {\n  var min_angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max_angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 360;\n  var loop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var round = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  if (loop) {\n    angle = angle % max_angle;\n    angle = angle < min_angle ? angle + max_angle : angle;\n  } else {\n    if (angle > max_angle) {\n      angle = max_angle;\n    }\n    if (angle < min_angle) {\n      angle = min_angle;\n    }\n  }\n  return round ? Math.round(angle) : angle;\n});\n_defineProperty(WoopMath, \"value_range\", function (value, min, max) {\n  var loop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (loop) {\n    if (value > max) {\n      return min + value % max;\n    }\n    if (value > min) {\n      return max - value % max;\n    }\n  }\n  return Math.min(Math.max(value, min), max);\n});\n_defineProperty(WoopMath, \"random_int_range\", function () {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n});\n_defineProperty(WoopMath, \"point_to_angle\", function (point1, point2) {\n  var deltaY = point2.y - point1.y;\n  var deltaX = point2.x - point1.x;\n  return WoopMath.angle_range(WoopMath.radians_to_degrees(Math.atan2(deltaY, deltaX)), 0, 360, true, false);\n});\n_defineProperty(WoopMath, \"radians_to_degrees\", function (radians) {\n  return radians * WoopMath.piDeg;\n});\n_defineProperty(WoopMath, \"degrees_to_radians\", function (degrees) {\n  return degrees * WoopMath.piRad;\n});\n_defineProperty(WoopMath, \"binary_angle_to_degree\", function (binary_angle) {\n  //full circle is -32768 to 32767.\n  return WoopMath.angle_range(360 / 65535 * (binary_angle + 32768), 0, 360, true, false);\n});\n_defineProperty(WoopMath, \"angle_to_screen_x\", function (angle, screen_distance, demi_internal_width) {\n  if (angle >= 0) {\n    return Math.round(screen_distance - Math.tan(WoopMath.degrees_to_radians(angle)) * demi_internal_width);\n  }\n  return Math.round(Math.tan(WoopMath.degrees_to_radians(angle)) * -1 * demi_internal_width + screen_distance);\n});\n\n\n//# sourceURL=webpack://woop/./src/WoopMath.js?");

/***/ }),

/***/ "./src/const.js":
/*!**********************!*\
  !*** ./src/const.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CURSORS\": () => (/* binding */ CURSORS),\n/* harmony export */   \"DOOM\": () => (/* binding */ DOOM),\n/* harmony export */   \"GAME_STATES\": () => (/* binding */ GAME_STATES)\n/* harmony export */ });\nvar GAME_STATES = {\n  MENU: 0,\n  GAME: 1,\n  EDITOR: 2\n};\nvar CURSORS = {\n  ARROW: 0,\n  GRAB: 1\n};\nvar DOOM = {\n  MAP_LUMPS: {\n    THINGS: 1,\n    LINEDEFS: 2,\n    SIDEDEFS: 3,\n    VERTEXES: 4,\n    SEGS: 5,\n    SSECTORS: 6,\n    NODES: 7,\n    SECTORS: 8,\n    REJECT: 9,\n    BLOCKMAP: 10\n  },\n  SUB_SECTOR_ID: 0x8000\n};\n\n//# sourceURL=webpack://woop/./src/const.js?");

/***/ }),

/***/ "./src/type/Int2DVertex.js":
/*!*********************************!*\
  !*** ./src/type/Int2DVertex.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Int2DVertex)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar Int2DVertex = /*#__PURE__*/function () {\n  function Int2DVertex(x, y) {\n    _classCallCheck(this, Int2DVertex);\n    this.x = Math.round(x);\n    this.y = Math.round(y);\n  }\n  _createClass(Int2DVertex, [{\n    key: \"set_x\",\n    value: function set_x(x) {\n      this.x = Math.round(x);\n    }\n  }, {\n    key: \"set_y\",\n    value: function set_y(y) {\n      this.y = Math.round(y);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Int2DVertex(this.x, this.y);\n    }\n    //todo get distance from this\n  }]);\n  return Int2DVertex;\n}();\n\n\n//# sourceURL=webpack://woop/./src/type/Int2DVertex.js?");

/***/ }),

/***/ "./src/type/Int3DVertex.js":
/*!*********************************!*\
  !*** ./src/type/Int3DVertex.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Int3DVertex)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar Int3DVertex = /*#__PURE__*/function () {\n  function Int3DVertex(x, y, z) {\n    _classCallCheck(this, Int3DVertex);\n    this.x = Math.round(x);\n    this.y = Math.round(y);\n    this.z = Math.round(z);\n  }\n  _createClass(Int3DVertex, [{\n    key: \"set_x\",\n    value: function set_x(x) {\n      this.x = Math.round(x);\n    }\n  }, {\n    key: \"set_y\",\n    value: function set_y(y) {\n      this.y = Math.round(y);\n    }\n  }, {\n    key: \"set_z\",\n    value: function set_z(z) {\n      this.z = Math.round(z);\n    }\n    //todo get distance from this\n  }]);\n  return Int3DVertex;\n}();\n\n\n//# sourceURL=webpack://woop/./src/type/Int3DVertex.js?");

/***/ }),

/***/ "./src/woop.js":
/*!*********************!*\
  !*** ./src/woop.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Woop)\n/* harmony export */ });\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"./src/const.js\");\n/* harmony import */ var _WadLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WadLoader.js */ \"./src/WadLoader.js\");\n/* harmony import */ var _Level_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Level.js */ \"./src/Level.js\");\n/* harmony import */ var _Renderer2D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer2D.js */ \"./src/Renderer2D.js\");\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Game.js */ \"./src/Game.js\");\n/* harmony import */ var _Editor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Editor.js */ \"./src/Editor.js\");\n/* harmony import */ var _Debugger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Debugger.js */ \"./src/Debugger.js\");\n/* harmony import */ var _InputManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./InputManager.js */ \"./src/InputManager.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n\n\nvar Woop = /*#__PURE__*/function () {\n  function Woop(canvas) {\n    var _this = this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Woop);\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    _defineProperty(this, \"woop_loop\", function () {\n      var slice = 1 / _this.time.target_frame_rate - 0.005;\n      var accumulator = performance.now() / 1000 - _this.time.unscaledTime;\n      var current_second = Math.floor(performance.now() / 1000);\n      while (accumulator >= slice) {\n        _this.time.unscaledDeltaTime = performance.now() / 1000 - _this.time.unscaledTime;\n        _this.time.unscaledTime += _this.time.unscaledDeltaTime;\n        var deltaT = _this.time.unscaledDeltaTime;\n        if (deltaT > _this.time.maximumDeltaTime) {\n          deltaT = _this.time.maximumDeltaTime;\n        }\n        _this.time.deltaTime = deltaT * _this.time.timeScale;\n        _this.time.time += _this.time.deltaTime;\n        _this.update();\n        _this.debbuger.update();\n        accumulator -= slice;\n      }\n      _this.render();\n      _this.debbuger.render();\n      _this.time.frame_count++;\n      if (_this.time.last_second < current_second) {\n        _this.time.last_second = current_second;\n        _this.time.last_frame_count = _this.time.frame_count;\n        _this.time.frame_count = 0;\n      }\n      requestAnimationFrame(function () {\n        _this.woop_loop();\n      });\n    });\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    _defineProperty(this, \"update\", function () {\n      _this.inputs.resolve_keys();\n      switch (_this.game_state) {\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.GAME:\n          if (_this.inputs.input_status.has(\"editor_mode_release\")) {\n            _this.game_state = _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.EDITOR;\n          }\n          break;\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.EDITOR:\n          if (_this.inputs.input_status.has(\"game_mode_release\")) {\n            _this.game_state = _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.GAME;\n          }\n          break;\n      }\n      switch (_this.game_state) {\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.GAME:\n          _this.game.update();\n          break;\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.EDITOR:\n          _this.editor.update();\n          break;\n      }\n      _this.inputs.clear_mouse_movements();\n    });\n    _defineProperty(this, \"render\", function () {\n      switch (_this.game_state) {\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.GAME:\n          _this.game.render(_this.renderer);\n          break;\n        case _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.EDITOR:\n          _this.editor.render(_this.renderer);\n          break;\n      }\n    });\n    var render_mode = options.render !== undefined ? options.render : '2D';\n    var pixel_scale = options.scale !== undefined ? options.scale : 8;\n    var field_of_view = options.field_of_view !== undefined ? options.field_of_view : 90;\n    var player_height = options.player_height !== undefined ? options.player_height : 45;\n    var frame_rate = options.frame_rate !== undefined ? options.frame_rate : 30;\n    var debug = options.debug !== undefined ? options.debug : false;\n    switch (render_mode) {\n      case '2D':\n      default:\n        this.renderer = new _Renderer2D_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, canvas, field_of_view, pixel_scale, frame_rate);\n    }\n    this.game_state = _const_js__WEBPACK_IMPORTED_MODULE_0__.GAME_STATES.EDITOR;\n    this.debbuger = new _Debugger_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this, debug);\n    this.wad_loader = new _WadLoader_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, ['./wads/DOOM1.WAD']);\n    this.level = new _Level_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.level.load_from_wad(this.wad_loader, 'E1M1');\n    this.player = this.level.spawn_player(player_height);\n    this.inputs = new _InputManager_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this);\n    this.game = new _Game_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n    this.editor = new _Editor_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this);\n    this.time = {\n      target_frame_rate: frame_rate,\n      execution_start: window.performance.now(),\n      unscaledTime: 0,\n      unscaledDeltaTime: 0,\n      timeScale: 1,\n      time: 0,\n      deltaTime: 0,\n      maximumDeltaTime: 0.3333333,\n      frame_count: 0,\n      last_frame_count: 0,\n      last_second: 0\n    };\n  }\n  _createClass(Woop, [{\n    key: \"run\",\n    value: function run() {\n      this.woop_loop();\n    }\n  }]);\n  return Woop;\n}();\n\n\n//# sourceURL=webpack://woop/./src/woop.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/woop.js");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 
